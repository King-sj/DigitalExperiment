# 数字逻辑与数字系统课程设计报告

## 硬件环境描述

- 本课程设计选择的是拓展平台A: 基于 FPGA 的 minisys 平台

- 本课程设计利用 VIVADO 开发平台，用 Verilog 完成 a，b 的任务要求并实现了自主拓展任务，最后在 EGo1 板上实现所有要求。

- FPGA：Xilinx Artix-7系列XC7A35T-1CSG324C FPGA

## A. 电子钟设计

### 题目分析

#### 原题目要求

- 基本功能：要求用 Verilog 和原理图混编方式完成设计；实现24小时制时钟功能；实现整点报时功能；实现时间设置功能并且可以随意切换设置和正常工作模式。

- 附加功能：实现设置状态时闪烁显示、实现音乐整点报时、闹钟功能等等。

#### 小组题目分析

本题目要求设计一个基于FPGA的电子钟，包括基本功能和附加功能。

1. 基本功能：
- 实现24小时制时钟功能：需要设计一个能够显示24小时制时间的时钟，包括小时、分钟和秒的显示。
- 实现整点报时功能：需要设计一个在整点时刻（例如1:00, 2:00, 3:00等）触发报时功能的机制，选择声音或LED灯等方式进行报时。
- 实现时间设置功能并且可以随意切换设置和正常工作模式：需要设计一个可以设置时间的功能，并且能够方便地切换设置模式和正常工作模式。
2. 附加功能：
- 实现设置状态时闪烁显示：需要设计一个在设置状态下，时间显示会闪烁的机制，以便用户知道当前处于设置状态。
- 实现音乐整点报时：需要设计一个在整点时刻播放音乐的功能。
- 实现闹钟功能：需要设计一个可以设置闹钟时间的功能，当时间到达设定的闹钟时间时，会触发闹钟提醒功能，选择声音或LED灯等方式进行提醒。

### 团队分工

- 蔡逸文

- 宋健

- 李宇星

- 范兼玮

### 设计详解

#### 顶层模块 `module clock`

##### I. 顶层模块 `module clock`的输入输出

```verilog
module clock(
  input clk,  // 100MHz
  input reset,
  input set_mod,  // 设置模式
  input left,  // 按钮输入
  input right,
  input up,
  input down,
  output [3:0] sm_left_wei,  // 左边的数码管
  output [7:0] sm_left_duan,  //
  output [3:0] sm_right_wei,  //
  output [7:0] sm_right_duan,
  output beep,
  output sd
);
```

1. **输入信号**:
   - `clk`: 100MHz的时钟输入。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `set_mod`: 设置模式输入，用于切换时钟的设置模式。
   - `left`, `right`, `up`, `down`: 四个按钮输入，用于用户交互，如调整时间或在设置模式中导航。
2. **输出信号**:
   - `sm_left_wei` 和 `sm_left_duan`: 左边数码管的位选和段选信号。
   - `sm_right_wei` 和 `sm_right_duan`: 右边数码管的位选和段选信号。
   - `beep`: 蜂鸣器输出，用于发出声音提示。
   - `sd`: 音频输出，与`beep`一起用于发出更复杂的音频提示。

##### II. 分频
```verilog
reg one_hz_clk = 0;  // 1HZ
  reg [32:0] one_hz_counter;
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      one_hz_clk<=0;
      one_hz_counter<=0;
    end else begin
      if (one_hz_counter == 100000000/2-1) begin 
        one_hz_counter<=0;
        one_hz_clk<=~one_hz_clk;
      end else one_hz_counter <= one_hz_counter+1;
    end
  end
```
   - `one_hz_clk`是一个寄存器，用于生成1Hz的时钟信号。
   - `one_hz_counter`是一个33位的计数器，用于计数100MHz时钟信号的周期数，以便生成1Hz的信号。
   - 在每个时钟上升沿或复位信号时，计数器会递增或重置。当计数器达到50,000,000（100,000,000/2-1）时，它会重置并翻转`one_hz_clk`的值，从而生成1Hz的信号。

##### III. 去抖动
```verilog 
wire left_clean, right_clean, up_clean, down_clean;
  debounce db_left(
    .clk(clk),
    .reset(reset),
    .noisy_signal(left),
    .clean_signal(left_clean)
  );
  debounce db_right(
    .clk(clk),
    .reset(reset),
    .noisy_signal(right),
    .clean_signal(right_clean)
  );
  debounce db_up(
    .clk(clk),
    .reset(reset),
    .noisy_signal(up),
    .clean_signal(up_clean)
  );
  debounce db_down(
    .clk(clk),
    .reset(reset),
    .noisy_signal(down),
    .clean_signal(down_clean)
  );
```
   - `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。
##### IV. 计时
```verilog
  wire [5:0] seconds, minutes, hours;
  Ktime timer(
    .one_hz_clk(one_hz_clk), .reset(reset), .set_mod(set_mod),
    .set_hours(set_hours), .set_minutes(set_minutes), .set_seconds(set_seconds),
    .seconds(seconds), .minutes(minutes),.hours(hours)  // 输出
  );
```
   - `seconds`, `minutes`, `hours`是计时模块的输出信号，分别代表秒、分钟和小时。
   - `Ktime`模块是一个计时器，它使用1Hz的时钟信号来递增秒数，并在秒数达到60时递增分钟数，分钟数达到60时递增小时数。
   - `set_mod`信号用于控制计时器是否进入设置模式，`set_hours`, `set_minutes`, `set_seconds`是设置模式下的时间值。
##### V. 时间设置
```verilog
wire [5:0] set_seconds, set_minutes, set_hours;
wire [2:0] pos;
timer_setting timer_setter(
  .clk(clk), .reset(reset), .set_mod(set_mod), .left(left_clean), .right(right_clean),
  .up(up_clean), .down(down_clean), .hours(hours), .minutes(minutes), .seconds(seconds),
  .set_hours(set_hours), .set_minutes(set_minutes), .set_seconds(set_seconds),  // out
  .pos(pos)
);
```
   - `set_seconds`, `set_minutes`, `set_hours`是设置模式下的时间值。
   - `pos`是一个3位的信号，用于指示当前设置的位置（小时、分钟或秒）。
   - `timer_setting`模块允许用户通过按钮调整时间，并在设置模式下更新`set_hours`, `set_minutes`, `set_seconds`的值。
##### VI. 时间显示
```verilog
timer_show timer_shower(
  .clk(clk), .hours(hours), .minutes(minutes), .seconds(seconds),
  .pos(pos), .set_mod(set_mod),
  .left_wei(sm_left_wei),  // 输出
  .left_duan(sm_left_duan),
  .right_wei(sm_right_wei),
  .right_duan(sm_right_duan)
);
```
   - `timer_show`模块负责将当前时间或设置的时间显示在数码管上。
   - 它接收时钟信号、小时、分钟、秒以及位置和设置模式信号，并输出数码管的位选和段选信号。
##### VII. 音频播放
```verilog
wire beep_w;
assign beep = (minutes == 0) & beep_w;
audio_player audio(
  .clk(clk),
  .beep(beep_w),
  .sd(sd)
);
```
   - `beep_w`是一个内部信号，用于控制蜂鸣器。
   - `beep`信号在分钟数为零时（整点）被激活。
   - `audio_player`模块接收时钟信号、蜂鸣器控制信号，并输出音频信号`sd`。

#### 去抖动模块 `module debounce`

1. **模块定义**：
   ```verilog
   module debounce(
     input clk,  // 100MHz
     input reset,
     input noisy_signal,
     output reg clean_signal
   );
   ```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
   ```verilog
   reg [20:0] counter;
   reg stable_signal;
   ```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
   ```verilog
   always @(posedge clk, negedge reset) begin
     if (~reset) begin
       counter <= 0;
       clean_signal <= 0;
       stable_signal <= 0;
     end else begin
       // ...
     end
   end
   ```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（低电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
   ```verilog
   if (noisy_signal == stable_signal) begin
     // 当输入信号与当前稳定信号相同时，增加计数器
     if (counter < 2000000)  // 等待大约20ms
       counter <= counter + 1;
     else
       clean_signal <= stable_signal;  // 更新输出信号
   end else begin
     // 如果输入信号改变，重置计数器并更新稳定信号
     counter <= 0;
     stable_signal <= noisy_signal;
   end
   ```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### 计数模块 `module counter`

1. **模块定义**：
   ```verilog
   module counter(
     input clk,
     input reset,
     input enable,
     input set,
     input [31:0] set_count,
     output reg [31:0] count,
     output reg carry_out
   );
   ```
- 这行代码定义了名为 `counter` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`reset` 是复位信号，`enable` 是使能信号，`set` 是设置信号，`set_count` 是设置的计数值，`count` 是当前计数值的输出，`carry_out` 是进位输出。
2. **参数定义**：
   ```verilog
   parameter MAX_COUNT = 59; // 默认最大计数值为 59
   ```
- 这个参数定义了计数器的最大计数值。
3. **时序逻辑**：
   ```verilog
   always @(posedge clk or posedge reset) begin
     if (reset) begin
       count <= 0;
       carry_out <= 0;
     end else if (set) begin
       count <= set_count;
       carry_out <= 0;
     end else if (enable) begin
       if (count == MAX_COUNT) begin
         count <= 0;
         carry_out <= 0;
       end else begin
         count <= count + 1;
         if(count == MAX_COUNT-1) begin  // 提前触发
           carry_out <= 1;
         end else begin
           carry_out <= 0;
         end
       end
     end else begin
       carry_out <= 0;
     end
   end
   ```
- 这个 `always` 块是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。如果复位信号被激活（高电平），则计数器和进位输出都被重置为 0。如果设置信号被激活（高电平），则计数器被设置为 `set_count` 的值，进位输出被重置为 0。如果使能信号被激活（高电平），则计数器递增，并且当计数器达到最大值时，计数器被重置为 0，进位输出也被重置为 0。如果计数器在达到最大值之前进位，进位输出被提前触发为 1。如果使能信号不被激活，进位输出被保持为 0。

这个模块通过简单的计数机制实现了计数功能，并且可以根据设置信号和使能信号来控制计数器的值和进位输出。


#### 计时模块 `module Ktime`

1. **模块定义**：
```verilog
module Ktime(
  input one_hz_clk,  // 1Hz时钟信号
  input reset,       // 复位信号
  input set_mod,     // 设置模式信号
  input [5:0] set_hours,  // 设置小时输入
  input [5:0] set_minutes,  // 设置分钟输入
  input [5:0] set_seconds,  // 设置秒输入
  output [5:0] seconds,  // 秒输出
  output [5:0] minutes,  // 分钟输出
  output [5:0] hours    // 小时输出
);
```
- 这个模块定义了时钟的基本输入和输出信号。
2. **内部连线**：
```verilog
wire sec_carry, min_carry;
```
- 这两个线是用来传递秒和分钟计数器的进位信号。
3. **计数器实例**：
```verilog
counter sec_counter (
  .clk(one_hz_clk), .reset(reset), .enable(1'b1),
  .set(set_mod),.set_count(set_seconds),.count(seconds), .carry_out(sec_carry)
);
```
- `sec_counter`：秒计数器，当设置模式激活时，可以设置秒数。
```verilog
counter min_counter (
  .clk(one_hz_clk), .reset(reset), .enable(sec_carry),
  .set(set_mod),.set_count(set_minutes),.count(minutes), .carry_out(min_carry)
);
```
- `min_counter`：分钟计数器，当秒计数器的进位信号有效时，可以设置分钟数。
```verilog
counter hour_counter(
    .clk(one_hz_clk), .reset(reset), .enable(min_carry),
    .set(set_mod),.set_count(set_hours), .count(hours)
  );
```
- `hour_counter`：小时计数器，当分钟计数器的进位信号有效时，可以设置小时数。
4. **参数重定义**：
```verilog
defparam hour_counter.MAX_COUNT = 23;
```
- 这个参数重定义了小时计数器的最大值，设置为 23，因为小时计数器只需要计数到 23。
5. **计数器模块**：
- 这三个计数器模块都是基于 `counter` 模块。这个 `counter` 模块是一个 32 位计数器，它可以在设置模式激活时被设置为指定的值。当计数器达到最大值时，它会自动重置为 0。此外，它还有一个提前触发的进位输出，当计数器接近最大值时，输出会提前变为 1。

`Ktime` 模块通过这三个计数器实例创建了一个级联时钟，其中秒计数器每秒递增，分钟计数器在秒计数器进位时递增，小时计数器在分钟计数器进位时递增。当设置模式激活时，计数器可以被设置为 `set_hours`、`set_minutes` 和 `set_seconds` 提供的值。

#### 时间设置模块 `module timer_setting`

1. **模块定义**：
```verilog
module timer_setting(
  input clk,  // 100MHz
  input reset,
  input set_mod,
  input left,
  input right,
  input up,
  input down,
  input [5:0] seconds,
  input [5:0] minutes,
  input [5:0] hours,
  output reg signed [32:0] set_hours,
  output reg signed [32:0] set_minutes,
  output reg signed [32:0] set_seconds,
  output reg [2:0] pos
);
```
- 这行代码定义了名为 `timer_setting` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`reset` 是复位信号，`set_mod` 是设置模式信号，`left`、`right`、`up` 和 `down` 是方向控制信号，`seconds`、`minutes` 和 `hours` 是当前时间的小时、分钟和秒，`set_hours`、`set_minutes` 和 `set_seconds` 是设置的时间的小时、分钟和秒，`pos` 指示当前设置的时间部分。
2. **保存前一个状态的寄存器**：
```verilog
reg left_prev;
reg right_prev;
reg up_prev;
reg down_prev;
```
- 这些寄存器用于保存前一个状态的 `left`、`right`、`up` 和 `down` 信号。
3. **方向控制逻辑**：
```verilog
always @(posedge clk or posedge reset) begin
  if (reset) begin
    pos <= 0;
    left_prev <= 0;
    right_prev <= 0;
  end else begin
    left_prev <= left;
    right_prev <= right;
    if (left && !left_prev && !right) begin
      if (pos == 5)
        pos <= 0;
      else
        pos <= pos + 1;
    end
    if (right && !right_prev && !left) begin
      if (pos == 0)
        pos <= 5;
      else
        pos <= pos - 1;
    end
  end
end
```
- 这个 `always` 块是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。它用于处理方向控制信号 `left` 和 `right`，并更新 `pos` 寄存器，指示当前设置的时间部分。
4. **时间设置逻辑**：
  ```verilog
  always @(posedge clk, posedge reset) begin
    if (reset) begin
      set_seconds <= 0;
      set_minutes <= 0;
      set_hours <= 0;
    end else if (set_mod) begin
      up_prev <= up;
      down_prev <= down;
      if (up && !up_prev && !down) begin
        case (pos)
          3'd0: set_seconds <= (set_seconds + 1) % 60;
          3'd1: set_seconds <= (set_seconds + 10) % 60;
          3'd2: set_minutes <= (set_minutes + 1) % 60;
          3'd3: set_minutes <= (set_minutes + 10) % 60;
          3'd4: set_hours   <= (set_hours + 1) % 24;
          3'd5: set_hours   <= (set_hours + 10) % 24;
        endcase
      
      end else if (down && !down_prev && !up) begin
        case (pos)
          3'd0: set_seconds <= (set_seconds - 1 + 60) % 60;
          3'd1: set_seconds <= (set_seconds - 10 + 60) % 60;
          3'd2: set_minutes <= (set_minutes - 1 + 60) % 60;
          3'd3: set_minutes <= (set_minutes - 10 + 60) % 60;
          3'd4: set_hours   <= (set_hours - 1 + 24) % 24;
          3'd5: set_hours   <= (set_hours - 10 + 24) % 24;
        endcase
      end
    end else if (~set_mod) begin
      set_hours <= hours;
      set_minutes <= minutes;
      set_seconds <= seconds;
    end
  end
  endmodule
```
- 这个 `always` 块也是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。如果 `set_mod` 信号有效（高电平），则它将处理方向控制信号 `up` 和 `down`，并根据 `pos` 寄存器的值增加或减少时间。如果 `set_mod` 信号无效（低电平），则它将输出当前的时间值 `hours`、`minutes` 和 `seconds`。

这个模块通过处理方向控制信号和设置模式信号来允许用户设置时钟时间。当 `set_mod` 信号被激活时，用户可以通过按下 `up` 和 `down` 按钮来增加或减少时间。当 `set_mod` 信号被清除时，模块将输出当前设置的时间值。

#### 时间显示模块 `module timer_show`

这个 `timer_show` 模块是一个用于显示时钟时间的 Verilog 模块。它接收一个时钟信号 `clk`，当前时间的小时、分钟和秒，当前设置的时间部分 `pos`，设置模式信号 `set_mod`，以及输出信号到左边的数码管和右边的数码管。
以下是 `timer_show` 模块的详细分析：
1. **模块定义**：
```verilog
module timer_show(
  input clk,
  input [5:0]hours,
  input [5:0]minutes,
  input [5:0]seconds,
  input [2:0] pos,
  input set_mod,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan
);
```
- 这行代码定义了名为 `timer_show` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`hours`、`minutes` 和 `seconds` 是当前时间的小时、分钟和秒，`pos` 指示当前设置的时间部分，`set_mod` 是设置模式信号，`left_wei`、`left_duan`、`right_wei` 和 `right_duan` 是输出信号到左边的数码管和右边的数码管。
2. **分频逻辑**：
```verilog
reg clk_2Hz = 0;  // 1HZ
reg [32:0] counter_2Hz=0;
always @(posedge clk) begin
  if (counter_2Hz == 50000000/2-1) begin
    counter_2Hz<=0;
    clk_2Hz<=~clk_2Hz;
  end else counter_2Hz <= counter_2Hz+1;
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 2Hz 的时钟信号 `clk_2Hz`。
3. **闪烁逻辑**：
```verilog
wire [2:0] flash_pos;
reg[7:0] flash = 0;
always @(posedge clk_2Hz) begin
  if (set_mod) begin
    flash <= ~flash;
  end else begin
    flash <= ~(8'd0);
  end
end
wire [3:0] select_wei;
assign select_wei = 1 << flash_pos;
assign left_duan = (pos > 3 && select_wei == left_wei) ?
  (flash & sm_left_duan) : sm_left_duan;
assign right_duan = (pos <= 3 && select_wei == right_wei) ?
  (flash & sm_right_duan) : sm_right_duan;
```
- 这个部分用于控制数码管的闪烁。当 `set_mod` 信号有效时，数码管会闪烁；否则，数码管将不闪烁。
4. **获取段选信号和位选信号**：
```verilog
reg [15:0] left_data, right_data;
wire [3:0] hours_high, hours_low, minutes_high, minutes_low, seconds_high, seconds_low;
assign hours_high = hours/10;
assign hours_low = hours%10;
assign minutes_high = minutes/10;
assign minutes_low = minutes%10;
assign seconds_high = seconds/10;
assign seconds_low = seconds%10;
always @(posedge clk) begin
  left_data <= {hours_low,hours_high,{4'b1111},{4'b1111}};  // TODO(SJ): just test pos
  right_data <= {seconds_low,seconds_high,minutes_low,minutes_high};
end
```
- 这个部分用于将小时、分钟和秒转换为段选信号和位选信号，并输出到左边的数码管和右边的数码管。
5. **数码管显示模型**：
```verilog
smg_ip_model smg_left(
  .clk(clk), .data(left_data),
  .sm_wei(left_wei), .sm_duan(sm_left_duan)  // 位选信号不用处理，直接输出即可
);
smg_ip_model smg_right(
  .clk(clk), .data(right_data),
  .sm_wei(right_wei), .sm_duan(sm_right_duan)
);
```
- 这两个部分分别定义了左边的数码管和右边的数码管的显示模型。它们接收时钟信号 `clk`，段选信号 `sm_wei` 和位选信号 `sm_duan`，以及数据信号 `data`，并将其显示在数码管上。

这个模块通过处理时钟信号、当前时间、设置模式信号以及输入的数码管控制信号，来显示当前的时间。当 `set_mod` 信号有效时，数码管会显示设置的时间；否则，它会显示当前的时间。

#### 数码管显示模块 `module smg_ip_model`
1. **模块定义**：
```verilog
module smg_ip_model(clk,data,sm_wei,sm_duan);
```
- 定义了名为 `smg_ip_model` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`data` 是输入的数据信号，`sm_wei` 是位选信号，`sm_duan` 是段选信号。
2. **分频逻辑**：
```verilog
integer clk_cnt=0;
reg clk_1kHz=0;
always @(posedge clk) begin
  if(clk_cnt==32'd50000-1)
    begin clk_cnt <= 1'b0; clk_1kHz <= ~clk_1kHz;end
  else begin
    clk_cnt <= clk_cnt + 1'b1;
  end
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 1kHz 的时钟信号 `clk_1kHz`。
3. **位控制逻辑**：
```verilog
reg [3:0]wei_ctrl=4'b1110;
always @(posedge clk_1kHz) begin
  wei_ctrl <= {wei_ctrl[2:0],wei_ctrl[3]};  // 循环移位
end
```
- 这个部分用于控制位选信号 `sm_wei`。它将 `wei_ctrl` 寄存器的值进行循环移位，以产生不同的位选信号。
4. **段控制逻辑**：
```verilog
reg [3:0]duan_ctrl;
always @(posedge clk) begin
  case(wei_ctrl)
    // ...
  default : duan_ctrl=4'hf;
  endcase
end
```
- 这个部分用于控制段选信号 `sm_duan`。它根据位选信号 `wei_ctrl` 的值，选择相应的段选信号 `duan_ctrl`，并将它输出到 `sm_duan`。
5. **解码模块**：
```verilog
reg [7:0]duan;
always @(posedge clk) begin
  case(duan_ctrl)
    // ...
  default : duan = 8'b0000_0000;//none
  endcase
end
```
- 这个部分用于解码段选信号 `duan_ctrl`，并输出相应的段选信号 `duan`。
6. **输出信号**：
```verilog
assign sm_wei =~wei_ctrl;
assign sm_duan = duan;
```
- 这两个部分分别将位选信号 `wei_ctrl` 和段选信号 `duan` 输出到 `sm_wei` 和 `sm_duan`。

这个模块通过处理时钟信号、输入的数据信号和位选信号，来输出相应的段选信号，从而控制数码管显示不同的数字或符号。

#### 音频播放模块 `module audio_player`

1. **模块定义**：
```verilog
module audio_player(
  input clk,
  output beep, // 蜂鸣器输出
  output sd
);
```
- 定义名为 `audio_player` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`beep` 是蜂鸣器控制信号，`sd` 是 SD卡控制信号。
2. **内部寄存器**：
```verilog
reg beep_r;
reg[7:0] state;  // 乐谱状态机
reg[16:0] count, pre_number;
reg[25:0] beat_time;
```
- 这些寄存器用于存储和控制音频播放的状态和计数。
3. **输出信号**：
```verilog
assign sd = 1'b1;
```
- 这个部分将 SD 卡控制信号 `sd` 固定为高电平。
4. **参数定义**：
```verilog
parameter L_1 = 18'd127552,  // 低音1
  L_2 = 18'd113636,  // 低音2
  L_3 = 18'd101236,  // 低音3
  L_4 = 18'd95548,  // 低音4
  L_5 = 18'd85136,  // 低音5
  L_6 = 18'd75838,  // 低音6
  L_7 = 18'd67567,  // 低音7
  M_1 = 18'd63776,  // 中音1
  M_2 = 18'd56818,  // 中音2
  M_3 = 18'd50607,  // 中音3
  M_4 = 18'd47778,  // 中音4
  M_5 = 18'd42553,  // 中音5
  M_6 = 18'd37936,  // 中音6
  M_7 = 18'd33783;  // 中音7
parameter TIME = 50000000; // 每种音阶持续时长为500ms
```
- 这些参数定义了乐谱中不同音符的频率和持续时长。
5. **蜂鸣器控制逻辑**：
```verilog
assign beep = beep_r;
```
- 这个部分将蜂鸣器控制信号 `beep` 设置为 `beep_r` 的值。
6. **计数器逻辑**：
```verilog
always @(posedge clk) begin
  count <= count + 1'b1;
  if(count == pre_number) begin
    count <= 17'h0;
    beep_r <= !beep_r;  // 实际上每个周期分别包括等时长的高电位和低电位，一高一低反复循环，形成不同频率的声音
  end
end
```
- 这个部分用于控制蜂鸣器的频率。它通过计数器 `count` 来控制蜂鸣器的高低电平持续时间。
7. **乐谱状态机逻辑**：
```verilog
always @(posedge clk) begin
  if(beat_time < TIME)
    beat_time = beat_time + 1'b1;
  else begin
    beat_time = 26'd0;
    if(state == 8'd13)
      state = 8'd0;
    else
      state = state + 1'b1;
  case(state)
    8'D0:pre_number=L_1;
    8'D1:pre_number=L_2;
    8'D2:pre_number=L_3;
    8'D3:pre_number=L_4;
    8'D4:pre_number=L_5;
    8'D5:pre_number=L_6;
    8'D6:pre_number=L_7;
    8'D7:pre_number=M_1;
    8'D8:pre_number=M_2;
    8'D9:pre_number=M_3;
    8'D10:pre_number=M_4;
    8'D11:pre_number=M_5;
    8'D12:pre_number=M_6;
    8'D13:pre_number=M_7;
    default: pre_number = 16'h0;
   endcase
  end
end
```
- 这个部分用于控制乐谱的播放。它通过状态机 `state` 来选择不同的音符，并通过计数器 `beat_time` 来控制每个音符的持续时长。当 `beat_time` 达到预设的时长 `TIME` 时，状态机 `state` 自动切换到下一个音符，并重置 `beat_time`。

这个模块通过时钟信号 `clk` 控制蜂鸣器的频率和乐谱的播放。当蜂鸣器频率改变时，它会发出不同的音调；当乐谱状态机切换到下一个音符时，它会播放不同的音阶。

#### 管脚分配

本组直接通过编写`clock.xdc`约束文件来完成引脚分配。

以下是`clock.xdc`的引脚和信号分配的表格：

| 信号                | 引脚  | IOSTANDARD |
|---------------------|-------|------------|
| clk                 | P17   | LVCMOS33   |
| reset               | R1    | LVCMOS33   |
| down                | R17   | LVCMOS33   |
| left                | V1    | LVCMOS33   |
| right               | R11   | LVCMOS33   |
| up                  | U4    | LVCMOS33   |
| set_mod             | N4    | LVCMOS33   |
| beep                | T1    | LVCMOS33   |
| sd                  | M6    | LVCMOS33   |
| sm_left_duan[0]     | B4    | LVCMOS33   |
| sm_left_duan[1]     | A4    | LVCMOS33   |
| sm_left_duan[2]     | A3    | LVCMOS33   |
| sm_left_duan[3]     | B1    | LVCMOS33   |
| sm_left_duan[4]     | A1    | LVCMOS33   |
| sm_left_duan[5]     | B3    | LVCMOS33   |
| sm_left_duan[6]     | B2    | LVCMOS33   |
| sm_left_duan[7]     | D5    | LVCMOS33   |
| sm_right_duan[0]    | D4    | LVCMOS33   |
| sm_right_duan[1]    | E3    | LVCMOS33   |
| sm_right_duan[2]    | D3    | LVCMOS33   |
| sm_right_duan[3]    | F4    | LVCMOS33   |
| sm_right_duan[4]    | F3    | LVCMOS33   |
| sm_right_duan[5]    | E2    | LVCMOS33   |
| sm_right_duan[6]    | D2    | LVCMOS33   |
| sm_right_duan[7]    | H2    | LVCMOS33   |
| sm_left_wei[0]      | G2    | LVCMOS33   |
| sm_left_wei[1]      | C2    | LVCMOS33   |
| sm_left_wei[2]      | C1    | LVCMOS33   |
| sm_left_wei[3]      | H1    | LVCMOS33   |
| sm_right_wei[0]     | G1    | LVCMOS33   |
| sm_right_wei[1]     | F1    | LVCMOS33   |
| sm_right_wei[2]     | E1    | LVCMOS33   |
| sm_right_wei[3]     | G6    | LVCMOS33   |

此外，还有以下组合逻辑允许的属性设置：
- `ALLOW_COMBINATORIAL_LOOPS TRUE [get_nets timer_setter/p_1_in[2]]`
- `ALLOW_COMBINATORIAL_LOOPS TRUE [get_nets timer_setter/left_data[6]_i_2]`


### 调试过程中的问题及讨论

### 设计调试小结

## B. 药片装瓶系统设计

### 题目分析

#### 原题目要求

- 基本功能：实现药片装瓶功能；能够同时显示药瓶以及药片数量；有工作状态以及告警指示；有清零状态、设置状态和工作状态，实现状态间正确切换设置。

- 附加功能：实现设置状态时闪烁显示、工作状态时可以切换显示初始设置、可以设定每瓶药片数以及总药片数量限定等等。

#### 小组题目分析

本题目要求设计一个基于FPGA的药片装瓶系统，包括基本功能和附加功能。
1. 基本功能：
- 实现药片装瓶功能：需要设计一个能够模拟药片装瓶过程的系统，可以检测药片的数量，并将其装入药瓶中。
- 能够同时显示药瓶以及药片数量：需要设计一个显示系统，能够同时显示当前药瓶的数量和每个药瓶中的药片数量。
- 有工作状态以及告警指示：需要设计一个工作状态指示灯，以及一个告警指示灯，用于指示系统的工作状态和告警状态。
- 有清零状态、设置状态和工作状态，实现状态间正确切换设置：需要设计一个状态机，能够实现清零状态、设置状态和工作状态之间的正确切换。
2. 附加功能：
- 实现设置状态时闪烁显示：需要设计一个在设置状态下，显示系统会闪烁的机制，以便用户知道当前处于设置状态。
- 工作状态时可以切换显示初始设置：需要设计一个在工作状态下，可以切换显示初始设置的机制，以便用户可以查看初始设置信息。
- 可以设定每瓶药片数以及总药片数量限定：需要设计一个设置功能，可以设定每瓶药片的数量以及总药片数量的限定，以便用户可以根据需要进行设置。

### 团队分工

- 蔡逸文

- 宋健

- 李宇星

- 范兼玮

### 设计详解

#### 顶层模块 `module tabletFillingMachine`

##### I. 顶层模块 `module tabletFillingMachine`的输入输出

```verilog
module tabletFillingMachine(
  input clk,
  input reset,
  input set,
  input fill,
  input left,
  input right,
  input up,
  input down,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan,
  output beep,
  output sd
);
```

1. **输入信号**:
   - `clk`: 100MHz的时钟输入。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `set`: 设置模式输入，用于进入设置模式。
   - `fill`: 填充信号，表示药片填充操作正在进行。
   - `left`, `right`, `up`, `down`: 四个按钮输入，用于在设置模式中导航。
2. **输出信号**:
   - `sm_left_wei` 和 `sm_left_duan`: 左边数码管的位选和段选信号。
   - `sm_right_wei` 和 `sm_right_duan`: 右边数码管的位选和段选信号。
   - `beep`: 蜂鸣器输出，用于发出声音提示。
   - `sd`: 音频输出，与`beep`一起用于发出更复杂的音频提示。

##### II. 状态定义
```verilog
reg[1:0] IDLE = 2'b00, SETTING = 2'b01, WORKING = 2'b10, ALARM = 2'b11;
reg[1:0] state = 2'b10;
reg[31:0] TABLET_CNT_SUM = 32'd20, CAPACITY = 32'd9;
reg[31:0] tablet_cnt = 32'd0, bottle_cnt = 32'd0;
```
   - `IDLE`, `SETTING`, `WORKING`, `ALARM`是状态寄存器，用于表示机器的不同状态。
   - `TABLET_CNT_SUM`和`bottle_cnt`是计数器，分别用于记录总的药片数量和当前药瓶的药片数量。
   - `tablet_cnt`是当前填充的药片数量，`CAPACITY`是药瓶容量。

##### III. 去抖动
```verilog 
wire fill_clean;
debounce db_fill(
  .clk(clk), .reset(reset), .noisy_signal(fill),
  .clean_signal(fill_clean)
);
wire left_clean, right_clean, up_clean, down_clean;
debounce db_left(
  .clk(clk),
  .reset(reset),
  .noisy_signal(left),
  .clean_signal(left_clean)
);
debounce db_right(
  .clk(clk),
  .reset(reset),
  .noisy_signal(right),
  .clean_signal(right_clean)
);
debounce db_up(
  .clk(clk),
  .reset(reset),
  .noisy_signal(up),
  .clean_signal(up_clean)
);
debounce db_down(
  .clk(clk),
  .reset(reset),
  .noisy_signal(down),
  .clean_signal(down_clean)
);
```
   - `fill_clean`, `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。

##### IV. 状态转换
```verilog
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    state <= WORKING;
  end else begin
    if ((tablet_cnt + bottle_cnt * CAPACITY >= TABLET_CNT_SUM) ||
        (CAPACITY > 999) || (TABLET_CNT_SUM > 99) ||
        (tablet_cnt > 999) || (bottle_cnt > 999)
    ) begin
        state <= ALARM;
    end else if (set) begin
        state <= SETTING;  // 状态转换
    end else begin
        state <= WORKING;
    end
  end
end
```
- `always @(posedge clk, negedge reset)`块用于状态转换。
- 当满足某些条件（如药片和药瓶计数超过设定值）时，机器进入`ALARM`状态。
- 当`set`信号被激活时，机器进入`SETTING`状态。
- 其他情况下，机器保持在`WORKING`状态。
##### V. 药片填充
```verilog
reg fill_pre = 0;
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    tablet_cnt <= 0;
    bottle_cnt <= 0;
  end else if (state == WORKING) begin
    fill_pre <= fill_clean;
    if (fill_clean && !fill_pre) begin
      if (tablet_cnt == CAPACITY-1) begin
        bottle_cnt <= bottle_cnt + 1;
        tablet_cnt <= 0;
      end else begin
        tablet_cnt <= tablet_cnt + 1;
      end
    end
  end
end
```
- `always @(posedge clk, negedge reset)`块用于药片填充。
- `fill_pre`是填充信号的前一个值。
- 当检测到填充信号的上升沿时，如果当前药瓶的药片数量达到设定的容量，则增加药瓶计数并重置药片计数。否则，只增加药片计数。

##### VI. 设置模式
```verilog
reg[2:0] pos;
reg left_pre, right_pre, up_pre, down_pre;
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    pos <= 0;
  end else if (state == SETTING) begin
    left_pre <= left_clean;
    right_pre <= right_clean;
    up_pre <= up_clean;
    down_pre <= down_clean;
    if (left_clean && !left_pre) begin
      pos <= pos+1;
    end else if (right_clean && !right_pre) begin
      pos <= pos-1;
    end else if (up_clean && !up_pre) begin
      case(pos)
        3'd0: TABLET_CNT_SUM <= TABLET_CNT_SUM+1;
        3'd1: TABLET_CNT_SUM <= TABLET_CNT_SUM+10;
        3'd2: TABLET_CNT_SUM <= TABLET_CNT_SUM+100;
        // 3'd3: TABLET_CNT_SUM <= TABLET_CNT_SUM+1000;
        3'd4: CAPACITY <= CAPACITY + 1;
        3'd5: CAPACITY <= CAPACITY + 10;
        3'd6: CAPACITY <= CAPACITY + 100;
        // 3'd7: CAPACITY <= CAPACITY + 1000;
        default:;
      endcase
    end else if (down_clean && !down_pre) begin
      case(pos)
        3'd0: TABLET_CNT_SUM <= TABLET_CNT_SUM-1;
        3'd1: TABLET_CNT_SUM <= TABLET_CNT_SUM-10;
        3'd2: TABLET_CNT_SUM <= TABLET_CNT_SUM-100;
        // 3'd3: TABLET_CNT_SUM <= TABLET_CNT_SUM-1000;
        3'd4: CAPACITY <= CAPACITY - 1;
        3'd5: CAPACITY <= CAPACITY - 10;
        3'd6: CAPACITY <= CAPACITY - 100;
        // 3'd7: CAPACITY <= CAPACITY - 1000;
      endcase
    end
  end
end
```
- `pos`是一个3位的信号，用于指示当前设置的位置。根据`pos`的值，可以修改`TABLET_CNT_SUM`（总药片数量）和`CAPACITY`（每瓶药片数）。修改值的选择是基于`pos`的值，例如，`TABLET_CNT_SUM`可以增加1、10或100，而`CAPACITY`可以增加1、10或100。
- `always @(posedge clk, negedge reset)`块用于设置操作。
- 通过按钮操作，用户可以增加或减少总药片数量和药瓶的容量。

##### VII. 显示
```verilog
wire[31:0]tablet_cnt_show, bottle_cnt_show;
assign tablet_cnt_show = set ? TABLET_CNT_SUM : tablet_cnt;
assign bottle_cnt_show = set ? CAPACITY : bottle_cnt;
tablet_show shower(
  .clk(clk),
  .tablet_cnt(tablet_cnt_show),
  .bottle_cnt(bottle_cnt_show),
  .pos(pos),
  .set_mod(set),
  .left_wei(left_wei),  // 左边的数码管
  .left_duan(left_duan),  //
  .right_wei(right_wei),  //
  .right_duan(right_duan)
);
```
- `tablet_cnt_show`和`bottle_cnt_show`是显示信号，分别显示总的药片数量和当前药瓶的药片数量。 
- `tablet_show`模块负责将当前显示信号显示在数码管上。
##### VIII. 音频播放
```verilog
wire beep_w;
assign beep = (state == ALARM) & beep_w;
audio_player audio(
  .clk(clk),
  .beep(beep_w),
  .sd(sd)
);
```
   - `beep_w`是一个内部信号，用于控制蜂鸣器。 
   - `beep`信号在机器进入`ALARM`状态时被激活。 
   - `audio_player`模块接收时钟信号、蜂鸣器控制信号，并输出音频信号`sd`。

#### 去抖动模块 `module debounce`

1. **模块定义**：
```verilog
module debounce(
  input clk,  // 100MHz
  input reset,
  input noisy_signal,
  output reg clean_signal
);
```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
```verilog
reg [20:0] counter;
reg stable_signal;
```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
```verilog
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    counter <= 0;
    clean_signal <= 0;
    stable_signal <= 0;
  end else begin
    // ...
  end
end
```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（低电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
```verilog
if (noisy_signal == stable_signal) begin
  // 当输入信号与当前稳定信号相同时，增加计数器
  if (counter < 2000000)  // 等待大约20ms
    counter <= counter + 1;
  else
    clean_signal <= stable_signal;  // 更新输出信号
end else begin
  // 如果输入信号改变，重置计数器并更新稳定信号
  counter <= 0;
  stable_signal <= noisy_signal;
end
```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过简单的计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### 数码管显示模块 `module smg_ip_model`
1. **模块定义**：
```verilog
module smg_ip_model(clk,data,sm_wei,sm_duan);
```
- 定义了名为 `smg_ip_model` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`data` 是输入的数据信号，`sm_wei` 是位选信号，`sm_duan` 是段选信号。
2. **分频逻辑**：
```verilog
integer clk_cnt=0;
reg clk_1kHz=0;
always @(posedge clk) begin
  if(clk_cnt==32'd50000-1)
    begin clk_cnt <= 1'b0; clk_1kHz <= ~clk_1kHz;end
  else begin
    clk_cnt <= clk_cnt + 1'b1;
  end
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 1kHz 的时钟信号 `clk_1kHz`。
3. **位控制逻辑**：
```verilog
reg [3:0]wei_ctrl=4'b1110;
always @(posedge clk_1kHz) begin
  wei_ctrl <= {wei_ctrl[2:0],wei_ctrl[3]};  // 循环移位
end
```
- 这个部分用于控制位选信号 `sm_wei`。它将 `wei_ctrl` 寄存器的值进行循环移位，以产生不同的位选信号。
4. **段控制逻辑**：
```verilog
reg [3:0]duan_ctrl;
always @(posedge clk) begin
  case(wei_ctrl)
    // ...
  default : duan_ctrl=4'hf;
  endcase
end
```
- 这个部分用于控制段选信号 `sm_duan`。它根据位选信号 `wei_ctrl` 的值，选择相应的段选信号 `duan_ctrl`，并将它输出到 `sm_duan`。
5. **解码模块**：
```verilog
reg [7:0]duan;
always @(posedge clk) begin
  case(duan_ctrl)
    // ...
  default : duan = 8'b0000_0000;//none
  endcase
end
```
- 这个部分用于解码段选信号 `duan_ctrl`，并输出相应的段选信号 `duan`。
6. **输出信号**：
```verilog
assign sm_wei =~wei_ctrl;
assign sm_duan = duan;
```
- 这两个部分分别将位选信号 `wei_ctrl` 和段选信号 `duan` 输出到 `sm_wei` 和 `sm_duan`。

这个模块通过处理时钟信号、输入的数据信号和位选信号，来输出相应的段选信号，从而控制数码管显示不同的数字或符号。

#### 显示模块 `module tablet_show`

1. **模块定义**：
```verilog
module tablet_show(
  input clk,
  input [31:0] tablet_cnt,
  input [31:0] bottle_cnt,
  input [2:0] pos,
  input set_mod,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan
);
```
- 这行代码定义了名为 `tablet_show` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`tablet_cnt` 和 `bottle_cnt` 分别是药片计数和药瓶计数，`pos` 指示当前设置的时间部分，`set_mod` 是设置模式信号，`left_wei`、`left_duan`、`right_wei` 和 `right_duan` 是输出信号到左边的数码管和右边的数码管。
2. **分频逻辑**：
```verilog
reg clk_2Hz = 0;  // 1HZ
reg [32:0] counter_2Hz=0;
always @(posedge clk) begin
  if (counter_2Hz == 50000000/2-1) begin
    counter_2Hz<=0;
    clk_2Hz<=~clk_2Hz;
  end else counter_2Hz <= counter_2Hz+1;
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 2Hz 的时钟信号 `clk_2Hz`。
3. **闪烁逻辑**：
```verilog
wire [2:0] flash_pos;
reg[7:0] flash = 0;
always @(posedge clk_2Hz) begin
  if (set_mod) begin
    flash <= ~flash;
  end else begin
    flash <= ~(8'd0);
  end
end
wire [3:0] select_wei;
assign select_wei = 1 << flash_pos;
assign left_duan = (pos > 3 && select_wei == left_wei) ?
  (flash & sm_left_duan) : sm_left_duan;
assign right_duan = (pos <= 3 && select_wei == right_wei) ?
  (flash & sm_right_duan) : sm_right_duan;
```
- 这个部分用于控制数码管的闪烁。当 `set_mod` 信号有效时，数码管会闪烁；否则，数码管将不闪烁。
4. **获取段选信号和位选信号**：
```verilog
reg [15:0] left_data, right_data;
wire [3:0] bottle_hundreds, bottle_tens, bottle_units;
wire [3:0] tablet_hundreds, tablet_tens, tablet_units;
// 解码每个计数的各个位
assign bottle_hundreds  = (bottle_cnt / 100) % 10;
assign bottle_tens      = (bottle_cnt / 10) % 10;
assign bottle_units     = bottle_cnt % 10;
assign tablet_hundreds  = (tablet_cnt / 100) % 10;
assign tablet_tens      = (tablet_cnt / 10) % 10;
assign tablet_units     = tablet_cnt % 10;
always @(posedge clk) begin
  left_data <= {
    bottle_units, bottle_tens,
    bottle_hundreds, 4'Hf
  };
  right_data <= {
    tablet_units, tablet_tens,
    tablet_hundreds, 4'Hf
  };
end
```
- 这个部分用于将药片计数和药瓶计数转换为段选信号和位选信号，并输出到左边的数码管和右边的数码管。
5. **数码管显示模型**：
```verilog
smg_ip_model smg_left(
  .clk(clk), .data(left_data),
  .sm_wei(left_wei), .sm_duan(sm_left_duan)  // 位选信号不用处理，直接输出即可
);
smg_ip_model smg_right(
  .clk(clk), .data(right_data),
  .sm_wei(right_wei), .sm_duan(sm_right_duan)
);
```
- 这两个部分分别定义了左边的数码管和右边的数码管的显示模型。它们接收时钟信号 `clk`，段选信号 `sm_wei` 和位选信号 `sm_duan`，以及数据信号 `data`，并将其显示在数码管上。

这个模块通过处理时钟信号、药片计数、药瓶计数、设置模式信号以及输入的数码管控制信号，来显示当前的药片计数和药瓶计数。当 `set_mod` 信号有效时，数码管会显示设置的计数；否则，它会显示当前的计数。

#### 音频播放模块 `module audio_player`

1. **模块定义**：
```verilog
module audio_player(
  input clk,
  output beep, // 蜂鸣器输出
  output sd
);
```
- 定义名为 `audio_player` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`beep` 是蜂鸣器控制信号，`sd` 是 SD卡控制信号。
2. **内部寄存器**：
```verilog
reg beep_r;
reg[7:0] state;  // 乐谱状态机
reg[16:0] count, pre_number;
reg[25:0] beat_time;
```
- 这些寄存器用于存储和控制音频播放的状态和计数。
3. **输出信号**：
```verilog
assign sd = 1'b1;
```
- 这个部分将 SD 卡控制信号 `sd` 固定为高电平。
4. **参数定义**：
```verilog
parameter L_1 = 18'd127552,  // 低音1
  L_2 = 18'd113636,  // 低音2
  L_3 = 18'd101236,  // 低音3
  L_4 = 18'd95548,  // 低音4
  L_5 = 18'd85136,  // 低音5
  L_6 = 18'd75838,  // 低音6
  L_7 = 18'd67567,  // 低音7
  M_1 = 18'd63776,  // 中音1
  M_2 = 18'd56818,  // 中音2
  M_3 = 18'd50607,  // 中音3
  M_4 = 18'd47778,  // 中音4
  M_5 = 18'd42553,  // 中音5
  M_6 = 18'd37936,  // 中音6
  M_7 = 18'd33783;  // 中音7
parameter TIME = 50000000; // 每种音阶持续时长为500ms
```
- 这些参数定义了乐谱中不同音符的频率和持续时长。
5. **蜂鸣器控制逻辑**：
```verilog
assign beep = beep_r;
```
- 这个部分将蜂鸣器控制信号 `beep` 设置为 `beep_r` 的值。
6. **计数器逻辑**：
```verilog
always @(posedge clk) begin
  count <= count + 1'b1;
  if(count == pre_number) begin
    count <= 17'h0;
    beep_r <= !beep_r;  // 实际上每个周期分别包括等时长的高电位和低电位，一高一低反复循环，形成不同频率的声音
  end
end
```
- 这个部分用于控制蜂鸣器的频率。它通过计数器 `count` 来控制蜂鸣器的高低电平持续时间。
7. **乐谱状态机逻辑**：
```verilog
always @(posedge clk) begin
  if(beat_time < TIME)
    beat_time = beat_time + 1'b1;
  else begin
    beat_time = 26'd0;
    if(state == 8'd13)
      state = 8'd0;
    else
      state = state + 1'b1;
  case(state)
    8'D0:pre_number=L_1;
    8'D1:pre_number=L_2;
    8'D2:pre_number=L_3;
    8'D3:pre_number=L_4;
    8'D4:pre_number=L_5;
    8'D5:pre_number=L_6;
    8'D6:pre_number=L_7;
    8'D7:pre_number=M_1;
    8'D8:pre_number=M_2;
    8'D9:pre_number=M_3;
    8'D10:pre_number=M_4;
    8'D11:pre_number=M_5;
    8'D12:pre_number=M_6;
    8'D13:pre_number=M_7;
    default: pre_number = 16'h0;
   endcase
  end
end
```
- 这个部分用于控制乐谱的播放。它通过状态机 `state` 来选择不同的音符，并通过计数器 `beat_time` 来控制每个音符的持续时长。当 `beat_time` 达到预设的时长 `TIME` 时，状态机 `state` 自动切换到下一个音符，并重置 `beat_time`。

这个模块通过时钟信号 `clk` 控制蜂鸣器的频率和乐谱的播放。当蜂鸣器频率改变时，它会发出不同的音调；当乐谱状态机切换到下一个音符时，它会播放不同的音阶。

#### 管脚分配

本组直接通过编写 `TabletFillingMachine.xdc` 约束文件来完成引脚分配。

以下是 `TabletFillingMachine.xdc` 的引脚和信号分配的表格：

| 信号                | 引脚  | IOSTANDARD |
|---------------------|-------|------------|
| clk                 | P17   | LVCMOS33   |
| reset               | P15   | LVCMOS33   |
| down                | R17   | LVCMOS33   |
| left                | V1    | LVCMOS33   |
| right               | R11   | LVCMOS33   |
| up                  | U4    | LVCMOS33   |
| set                 | N4    | LVCMOS33   |
| fill                | R15   | LVCMOS33   |
| beep                | T1    | LVCMOS33   |
| sd                  | M6    | LVCMOS33   |
| left_duan[0]        | B4    | LVCMOS33   |
| left_duan[1]        | A4    | LVCMOS33   |
| left_duan[2]        | A3    | LVCMOS33   |
| left_duan[3]        | B1    | LVCMOS33   |
| left_duan[4]        | A1    | LVCMOS33   |
| left_duan[5]        | B3    | LVCMOS33   |
| left_duan[6]        | B2    | LVCMOS33   |
| left_duan[7]        | D5    | LVCMOS33   |
| right_duan[0]       | D4    | LVCMOS33   |
| right_duan[1]       | E3    | LVCMOS33   |
| right_duan[2]       | D3    | LVCMOS33   |
| right_duan[3]       | F4    | LVCMOS33   |
| right_duan[4]       | F3    | LVCMOS33   |
| right_duan[5]       | E2    | LVCMOS33   |
| right_duan[6]       | D2    | LVCMOS33   |
| right_duan[7]       | H2    | LVCMOS33   |
| left_wei[0]         | G2    | LVCMOS33   |
| left_wei[1]         | C2    | LVCMOS33   |
| left_wei[2]         | C1    | LVCMOS33   |
| left_wei[3]         | H1    | LVCMOS33   |
| right_wei[0]        | G1    | LVCMOS33   |
| right_wei[1]        | F1    | LVCMOS33   |
| right_wei[2]        | E1    | LVCMOS33   |
| right_wei[3]        | G6    | LVCMOS33   |

### 调试过程中的问题及讨论

### 设计调试小结

## 自主拓展：贪吃蛇

### 题目分析

- 实现一个简单的贪吃蛇游戏，玩家可以通过方向按钮来控制贪吃蛇的方向，通过吃食物来增加分数。
- 当贪吃蛇撞到墙壁或自己时，游戏结束，显示游戏结束标志。

### 团队分工

- 蔡逸文

- 宋健

- 李宇星

- 范兼玮

### 设计详解

#### 顶层模块 `module snake` 

##### I. 顶层模块 `module snake` 的输入输出

```verilog
module snake (
  input clk,
  input reset,
  input left,  // 按钮输入
  input right,
  input up,
  input down,
  output [3:0] red,
  output [3:0] green,
  output [3:0] blue,
  output hsync,
  output vsync,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan,
  inout ps2_clk,
  inout ps2_data
);
```
1. **输入信号**:
   - `clk`: 时钟信号，用于同步模块内的操作。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `left`, `right`, `up`, `down`: 方向按钮输入，用于控制贪吃蛇的方向。
   - `ps2_clk`, `ps2_data`: PS/2键盘输入，用于接收键盘输入。
2. **输出信号**:
   - `red`, `green`, `blue`: VGA信号输出，用于驱动显示器。
   - `hsync`, `vsync`: VGA信号输出，用于同步显示器。
   - `left_wei`, `left_duan`, `right_wei`, `right_duan`: 数码管输出，用于显示分数和游戏结束标志。

##### II. 内部信号
```verilog
wire [11:0]color;
wire [9:0]x,y;  // 640x480
wire valid;
wire [7:0] ascii_code;
wire right_p,left_p,up_p,down_p;
wire [15:0] score;
wire game_over;
```
   - `color`: 12位的颜色信号，用于VGA显示。
   - `x`, `y`: 坐标信号，用于VGA显示。
   - `valid`: 信号，用于指示键盘输入的有效性。
   - `ascii_code`: 8位的ASCII码信号，用于表示键盘输入的字符。
   - `right_p`, `left_p`, `up_p`, `down_p`: 信号，用于指示方向按钮的按下状态。
   - `score`: 16位的计数器，用于显示游戏分数。
   - `game_over`: 信号，用于指示游戏是否结束。

##### III. 去抖动
```verilog 
wire left_clean, right_clean, up_clean, down_clean;
debounce db_left(
  .clk(clk),
  .reset(reset),
  .noisy_signal(left),
  .clean_signal(left_clean)
);
debounce db_right(
  .clk(clk),
  .reset(reset),
  .noisy_signal(right),
  .clean_signal(right_clean)
);
debounce db_up(
  .clk(clk),
  .reset(reset),
  .noisy_signal(up),
  .clean_signal(up_clean)
);
debounce db_down(
  .clk(clk),
  .reset(reset),
  .noisy_signal(down),
  .clean_signal(down_clean)
);
```
   - `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。

##### IV. `VGA`
```verilog
vga vga_shower(
  .clk(clk),
  .new_data(color),
  .red(red),
  .green(green),
  .blue(blue),
  .hsync(hsync),
  .vsync(vsync),
  .pos_x(x),
  .pos_y(y)
);
```
   - `VGA`显示模块：负责显示游戏画面。

##### V. 键盘处理
```verilog
wire valid;
wire [7:0] ascii_code;
ps2 ps(clk, reset,ps2_clk,ps2_data,valid,ascii_code);
wire right_p,left_p,up_p,down_p;
assign right_p = right_clean || ascii_code == 8'h44;
assign left_p = left_clean || ascii_code == 8'h41;
assign up_p = up_clean || ascii_code == 8'h57;
assign down_p = down_clean || ascii_code == 8'h53;
```
- `wire valid;`：声明一个有效信号 `valid`，用于表示 PS/2 键盘输入的有效性。
- `wire [7:0] ascii_code;`：声明一个 8 位的信号 `ascii_code`，用于存储接收到的 PS/2 键盘传来的 ASCII 码值。
- `ps2 ps(clk, reset, ps2_clk, ps2_data, valid, ascii_code);`：实例化一个 PS/2 模块 `ps`，该模块用于接收 PS/2 键盘输入信号，并将有效信号和 ASCII 码值传递给 `valid` 和 `ascii_code`。
- `wire right_p, left_p, up_p, down_p;`：声明四个逻辑信号 `right_p`、`left_p`、`up_p`、`down_p`，用于表示贪吃蛇游戏中的四个方向控制。
- `assign right_p = right_clean || ascii_code == 8'h44;`：如果右方向键 `right` 被按下或者接收到键盘发送的ASCII码为 `8'h44`（即键盘上的特定按键对应的 ASCII 码），则 `right_p` 信号为高，表示向右移动。
- `assign left_p = left_clean || ascii_code == 8'h41;`：类似地，映射左移动。
- `assign up_p = up_clean || ascii_code == 8'h57;`：映射上移动。
- `assign down_p = down_clean || ascii_code == 8'h53;`：映射下移动。

##### VI. 贪吃蛇主体

```verilog
wire [15:0] score;
wire game_over;
snake_model snaker(
  .clk(clk),.reset(reset),
  .left(left_p),.right(right_p),.up(up_p),.down(down_p),
  .pix_x(x),.pix_y(y),
  .color(color),.score(score),.game_over(game_over)
);
```
   - 根据按钮输入和VGA坐标来控制贪吃蛇的行为

##### VI. 显示
```verilog
score_show score_shower(
  .clk(clk),
  .lcnt(0),
  .rcnt(score),
  .game_over(game_over),
  .left_wei(left_wei),  // 左边的数码管
  .left_duan(left_duan),  //
  .right_wei(right_wei),  //
  .right_duan(right_duan)
);
```
   - 接收游戏分数和游戏结束标志，并根据这些信息来控制数码管的显示。


#### 去抖动模块 `module debounce`

1. **模块定义**：
```verilog
module debounce(
  input clk,  // 100MHz
  input reset,
  input noisy_signal,
  output reg clean_signal
);
   ```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
```verilog
reg [20:0] counter;
reg stable_signal;
```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
```verilog
always @(posedge clk, posedge reset) begin
  if (reset) begin
    counter <= 0;
    clean_signal <= 0;
    stable_signal <= 0;
  end else begin
    // ...
  end
end
```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（高电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
```verilog
if (noisy_signal == stable_signal) begin
  // 当输入信号与当前稳定信号相同时，增加计数器
  if (counter < 2000000)  // 等待大约20ms
    counter <= counter + 1;
  else
    clean_signal <= stable_signal;  // 更新输出信号
end else begin
  // 如果输入信号改变，重置计数器并更新稳定信号
  counter <= 0;
  stable_signal <= noisy_signal;
end
```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### VGA 模块 `module vga`

1. **模块定义**
```verilog
module vga(
  input clk,          // 100MHz 时钟输入
  input [11:0]new_data,  // 下一个(r,g,b)
  output [3:0] red,   // 4位红色信号
  output [3:0] green, // 4位绿色信号
  output [3:0] blue,  // 4位蓝色信号
  output hsync,       // 水平同步信号
  output vsync,        // 垂直同步信号
  output [9:0] pos_x,  // 当前横坐标
  output [9:0] pos_y
);
```
- 定义一个名为`vga`的模块。
- `clk`：100MHz 时钟输入信号。
- `new_data`：由外部提供的 RGB 数据，12 位宽，共有红色、绿色和蓝色三部分信号，每部分信号 4 位。
- `red`、`green`、`blue`：VGA 显示的红、绿、蓝三原色信号，输出端口，每个信号 4 位。
- `hsync`：水平同步信号，输出端口，用于指示屏幕的行扫描。
- `vsync`：垂直同步信号，输出端口，用于指示屏幕的帧扫描。
- `pos_x`、`pos_y`：当前像素的横坐标和纵坐标，输出端口，用于定位当前像素位置。

2. **内部寄存器和信号**
```verilog
reg [9:0] hcount; //VGA 行扫描计数器
reg [9:0] vcount; //VGA 场扫描计数器
wire [11:0] data;  // (r,g,b)
reg [1:0]cnt;
wire hcount_ov;
wire vcount_ov;
wire dat_act;
reg vga_clk;
```
- `hcount`：用于表示当前行扫描的位置（像素计数）。
- `vcount`：用于表示当前场扫描的位置（行计数）。
- `data`：用于存储当前需要显示的RGB数据。
- `cnt`：2 位计数器，用于生成 VGA 时钟（25MHz）。
- `hcount_ov`：水平计数器溢出信号。
- `vcount_ov`：垂直计数器溢出信号。
- `dat_act`：激活显示数据的标志信号。
- `vga_clk`：VGA 时钟信号。

3. **参数定义**
```verilog
parameter
  hsync_end = 10'd95,
  hdat_begin = 10'd143,
  hdat_end = 10'd783,
  hpixel_end = 10'd799,
  vsync_end = 10'd1,
  vdat_begin = 10'd34,
  vdat_end = 10'd514,
  vline_end = 10'd524;
```
定义了一些 VGA 时序相关的参数，主要规定了水平和垂直同步信号的周期，以及有效显示区域的范围。
- `hsync_end`：水平同步结束的像素位置，即HSYNC信号的宽度为95个像素。
- `hdat_begin`：水平显示数据开始的像素位置，HSYNC结束后还有一段背景色区域，到第143个像素位置开始显示数据。
- `hdat_end`：水平显示数据结束的像素位置，第783个像素位置数据显示结束。
- `hpixel_end`：水平一行的结束像素位置，总宽度为800个像素（0到799）。
- `vsync_end`：垂直同步结束的行位置，即VSYNC信号的高度为1行。
- `vdat_begin`：垂直显示数据开始的行位置，在一些前置的非显示行后，从第34行开始显示数据。
- `vdat_end`：垂直显示数据结束的行位置，第514行数据显示结束。
- `vline_end`：垂直一帧的结束行位置，总高度为525行（0到524）。

4. **时钟分频**

```verilog
always @(posedge clk) begin
  if(cnt==3)
    cnt <= 0;
  else
    cnt <= cnt + 1;
end
always @(posedge clk) begin
  if(cnt < 2)
    vga_clk <= 1;
  else
    vga_clk <= 0;
end
```
这部分代码使用一个 2 位计数器对输入时钟 `clk` 进行分频，从 100MHz 降至 25MHz，得到 `vga_clk`。

5. **行扫描和场扫描**

- 行扫描
```verilog
always @(posedge vga_clk) begin
  if (hcount_ov)
    hcount <= 10'd0;
  else
    hcount <= hcount + 10'd1;
end
assign hcount_ov = (hcount == hpixel_end);
```
在每个 VGA 时钟周期内，`hcount` 递增，当 `hcount` 达到`hpixel_end`（799）时溢出，重置为 0。

- 场扫描
```verilog
always @(posedge vga_clk) begin
  if (hcount_ov) begin
    if (vcount_ov)
      vcount <= 10'd0;
    else
      vcount <= vcount + 10'd1;
  end
end
assign vcount_ov = (vcount == vline_end);
```
在每行扫描结束时 (`hcount_ov` 为真)，`vcount` 递增，当 `vcount` 达到`vline_end`（524）时溢出，重置为 0。

6. **数据和同步信号输出**

```verilog
assign dat_act = ((hcount >= hdat_begin) && (hcount < hdat_end)) && ((vcount >= vdat_begin) && (vcount < vdat_end));
assign hsync = (hcount > hsync_end);
assign vsync = (vcount > vsync_end);
assign red = (dat_act) ? data[11:8] : 3'h00;
assign green = (dat_act) ? data[7:4] : 3'h00;
assign blue = (dat_act) ? data[3:0] : 3'h00;
```
- `dat_act` 用于判断当前时刻是否在有效显示区域内，只有在有效显示区内，`dat_act` 才为真。
- `hsync` 和 `vsync` 分别在它们的同步区间之外为真，表示显示器可以进行下一步行或帧的显示。
- `red`、`green` 和 `blue` 信号只有在有效显示区间内（`dat_act` 为真）才会被赋值为 `data` 的对应颜色分量，否则为 0。

7. **显示数据处理**
```verilog
assign pos_x = hcount-hdat_begin;
assign pos_y = vcount-vdat_begin;
assign data = new_data;
```
- `pos_x` 和 `pos_y` 分别表示当前像素在有效显示区域内的坐标。
- `data` 直接赋值为外部输入的 `new_data`。

#### PS2 模块 `module ps2`

1. **模块定义**
```verilog
module ps2(clk, reset,ps2k_clk,ps2k_data,ps2_state,ps2_asci);
input clk;    //时钟信号
input reset;  //复位信号
input ps2k_clk;  //PS2接口时钟信号
input ps2k_data;    //PS2接口数据信号
output ps2_state;    //键盘当前状态，ps2_state=1表示有键被按下
output reg[7:0] ps2_asci;  //接收数据的相应ASCII码
```
- `input clk`：输入时钟信号。
- `input reset`：输入复位信号。
- `input ps2k_clk`：PS/2键盘时钟信号。
- `input ps2k_data`：PS/2键盘数据信号。
- `output ps2_state`：键盘当前状态，表示是否有键被按下。
- `output reg [7:0] ps2_asci`：接收的数据的相应ASCII码。

### 内部信号和寄存器

- `ps2k_clk_r0`、`ps2k_clk_r1`、`ps2k_clk_r2`：用于滤波的PS/2时钟信号寄存器。
- `neg_ps2k_clk`：PS/2时钟的下降沿标志。
- `ps2_byte_r`：存储当前接收的一个字节数据。
- `temp_data`：当前接收数据的寄存器。
- `num`：用于计数数据位的计数器。

### 滤波和边沿检测

#### 滤波
```verilog
always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    ps2k_clk_r0 <= 1'b0;
    ps2k_clk_r1 <= 1'b0;
    ps2k_clk_r2 <= 1'b0;
  end else begin
    ps2k_clk_r0 <= ps2k_clk;
    ps2k_clk_r1 <= ps2k_clk_r0;
    ps2k_clk_r2 <= ps2k_clk_r1;
  end
end
```
用于对PS/2时钟信号进行滤波，以消除抖动。

#### 检测下降沿
```verilog
assign neg_ps2k_clk = ~ps2k_clk_r1 & ps2k_clk_r2;
```
检测PS/2时钟信号的下降沿，当检测到下降沿时，`neg_ps2k_clk`为高。

### 数据采集

```verilog
always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    num <= 4'd0;
    temp_data <= 8'd0;
  end else if(neg_ps2k_clk) begin
    case (num)
      4'd0: num <= num + 1'b1;
      4'd1: begin
        num <= num + 1'b1;
        temp_data[0] <= ps2k_data;  // bit0
      end
      4'd2: begin
        num <= num + 1'b1;
        temp_data[1] <= ps2k_data;  // bit1
      end
      4'd3: begin
        num <= num + 1'b1;
        temp_data[2] <= ps2k_data;  // bit2
      end
      4'd4: begin
        num <= num + 1'b1;
        temp_data[3] <= ps2k_data;  // bit3
      end
      4'd5: begin
        num <= num + 1'b1;
        temp_data[4] <= ps2k_data;  // bit4
      end
      4'd6: begin
        num <= num + 1'b1;
        temp_data[5] <= ps2k_data;  // bit5
      end
      4'd7: begin
        num <= num + 1'b1;
        temp_data[6] <= ps2k_data;  // bit6
      end
      4'd8: begin
        num <= num + 1'b1;
        temp_data[7] <= ps2k_data;  // bit7
      end
      4'd9: begin
        num <= num + 1'b1;  // 奇偶校验位，不做处理
      end
      4'd10: begin
        num <= 4'd0;  // num清零
      end
      default: ;
    endcase
  end
end
```
在每个PS/2时钟信号的下降沿采集数据位，将数据位依次存入`temp_data`，采集完成后计数器`num`清零。

### 数据处理

#### 松键标志和键盘状态
```verilog
reg key_f0;  // 松键标志位
reg ps2_state_r;  // 键盘当前状态

always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    key_f0 <= 1'b0;
    ps2_state_r <= 1'b0;
  end else if(num == 4'd10) begin  // 一帧数据是否采集完
    if(temp_data == 8'hf0) key_f0 <= 1'b1;  // 判断是否为断码
    else begin
      if(!key_f0) begin
        ps2_state_r <= 1'b1;  // 有键按下
        ps2_byte_r <= temp_data;  // 锁存当前键值
      end else begin
        ps2_state_r <= 1'b0;
        key_f0 <= 1'b0;
      end
    end
  end
end
assign ps2_state = ps2_state_r;
```
检测到`f0`码时，松键标志置1，否则判断是否为按键事件，并根据键值更新键盘状态。

#### ASCII码转换
```verilog
always @ (ps2_byte_r) begin
  case (ps2_byte_r)
    8'h15: ps2_asci <= 8'h51;  // Q
    8'h1d: ps2_asci <= 8'h57;  // W
    8'h24: ps2_asci <= 8'h45;  // E
    8'h2d: ps2_asci <= 8'h52;  // R
    8'h2c: ps2_asci <= 8'h54;  // T
    8'h35: ps2_asci <= 8'h59;  // Y
    8'h3c: ps2_asci <= 8'h55;  // U
    8'h43: ps2_asci <= 8'h49;  // I
    8'h44: ps2_asci <= 8'h4f;  // O
    8'h4d: ps2_asci <= 8'h50;  // P
    8'h1c: ps2_asci <= 8'h41;  // A
    8'h1b: ps2_asci <= 8'h53;  // S
    8'h23: ps2_asci <= 8'h44;  // D
    8'h2b: ps2_asci <= 8'h46;  // F
    8'h34: ps2_asci <= 8'h47;  // G
    8'h33: ps2_asci <= 8'h48;  // H
    8'h3b: ps2_asci <= 8'h4a;  // J
    8'h42: ps2_asci <= 8'h4b;  // K
    8'h4b: ps2_asci <= 8'h4c;  // L
    8'h1a: ps2_asci <= 8'h5a;  // Z
    8'h22: ps2_asci <= 8'h58;  // X
    8'h21: ps2_asci <= 8'h43;  // C
    8'h2a: ps2_asci <= 8'h56;  // V
    8'h32: ps2_asci <= 8'h42;  // B
    8'h31: ps2_asci <= 8'h4e;  // N
    8'h3a: ps2_asci <= 8'h4d;  // M
    default: ;
  endcase
end
```
根据接收到的扫描码，将其转换为相应的ASCII码。ASCII码的映射主要针对字母键。

总结：
1. 该模块从PS/2键盘接收数据，通过时钟边沿检测和数据采集实现数据接收。
2. 通过状态寄存器和相应的标志位实现键盘状态和按键状态的记录和处理。
3. 将接收到的扫描码转换为对应的ASCII码，以便于后续处理或显示。

### 调试过程中的问题及讨论

### 设计调试小结
