# 数字逻辑与数字系统课程设计报告

## 硬件环境描述

- 本课程设计选择的是拓展平台A: 基于 `FPGA` 的 `minisys` 平台

- 本课程设计利用 `VIVADO` 开发平台，用 `Verilog` 完成 a，b 的任务要求并实现了自主拓展任务，最后在 `EGo1` 板上实现所有要求。

- 型号：`Ego1: Artex-7`

- 器件: `xc7a35tcsg324-1`

- Flash型号：`N25Q32-3.3V`

### 团队分工

- 蔡逸文
  - 模块 `smg_ip_model`
  - 模块 `timer_show` `tablet_show` `score_show`
  - 模块 `tabletFillingMachine`

- 宋健
  - 模块 `fibonacci_lfsr`
  - 模块 `snake_model`
  - 模块 `vga`
  - 模块 `snake`

- 李宇星
  - 模块 `timer_setting`
  - 模块 `counter`
  - 模块 `Ktime`

- 范兼玮
  - 模块 `audio_player`
  - 模块 `clock`
  - 模块 `debounce`
 
## A. 电子钟设计

### 题目分析

#### 原题目要求

- 基本功能：要求用 Verilog 和原理图混编方式完成设计；实现24小时制时钟功能；实现整点报时功能；实现时间设置功能并且可以随意切换设置和正常工作模式。

- 附加功能：实现设置状态时闪烁显示、实现音乐整点报时、闹钟功能等等。

#### 小组题目分析

本题目要求设计一个基于FPGA的电子钟，包括基本功能和附加功能。

1. 基本功能：
- 实现24小时制时钟功能：需要设计一个能够显示24小时制时间的时钟，包括小时、分钟和秒的显示。
- 实现整点报时功能：需要设计一个在整点时刻（例如1:00, 2:00, 3:00等）触发报时功能的机制，选择声音或LED灯等方式进行报时。
- 实现时间设置功能并且可以随意切换设置和正常工作模式：需要设计一个可以设置时间的功能，并且能够方便地切换设置模式和正常工作模式。
2. 附加功能：
- 实现设置状态时闪烁显示：需要设计一个在设置状态下，时间显示会闪烁的机制，以便用户知道当前处于设置状态。
- 实现音乐整点报时：需要设计一个在整点时刻播放音乐的功能。
- 实现闹钟功能：需要设计一个可以设置闹钟时间的功能，当时间到达设定的闹钟时间时，会触发闹钟提醒功能，选择声音或LED灯等方式进行提醒。

### 设计详解

#### 顶层模块 `module clock`

##### I. 顶层模块 `module clock`的输入输出

```verilog
module clock(
  input clk,  // 100MHz
  input reset,
  input set_mod,  // 设置模式
  input left,  // 按钮输入
  input right,
  input up,
  input down,
  output [3:0] sm_left_wei,  // 左边的数码管
  output [7:0] sm_left_duan,  //
  output [3:0] sm_right_wei,  //
  output [7:0] sm_right_duan,
  output beep,
  output sd
);
```

1. **输入信号**:
   - `clk`: 100MHz的时钟输入。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `set_mod`: 设置模式输入，用于切换时钟的设置模式。
   - `left`, `right`, `up`, `down`: 四个按钮输入，用于用户交互，如调整时间或在设置模式中导航。
2. **输出信号**:
   - `sm_left_wei` 和 `sm_left_duan`: 左边数码管的位选和段选信号。
   - `sm_right_wei` 和 `sm_right_duan`: 右边数码管的位选和段选信号。
   - `beep`: 蜂鸣器输出，用于发出声音提示。
   - `sd`: 音频输出，与`beep`一起用于发出更复杂的音频提示。

##### II. 分频
```verilog
reg one_hz_clk = 0;  // 1HZ
  reg [32:0] one_hz_counter;
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      one_hz_clk<=0;
      one_hz_counter<=0;
    end else begin
      if (one_hz_counter == 100000000/2-1) begin 
        one_hz_counter<=0;
        one_hz_clk<=~one_hz_clk;
      end else one_hz_counter <= one_hz_counter+1;
    end
  end
```
   - `one_hz_clk`是一个寄存器，用于生成1Hz的时钟信号。
   - `one_hz_counter`是一个33位的计数器，用于计数100MHz时钟信号的周期数，以便生成1Hz的信号。
   - 在每个时钟上升沿或复位信号时，计数器会递增或重置。当计数器达到50,000,000（100,000,000/2-1）时，它会重置并翻转`one_hz_clk`的值，从而生成1Hz的信号。

##### III. 去抖动
```verilog 
wire left_clean, right_clean, up_clean, down_clean;
  debounce db_left(
    .clk(clk),
    .reset(reset),
    .noisy_signal(left),
    .clean_signal(left_clean)
  );
  debounce db_right(
    .clk(clk),
    .reset(reset),
    .noisy_signal(right),
    .clean_signal(right_clean)
  );
  debounce db_up(
    .clk(clk),
    .reset(reset),
    .noisy_signal(up),
    .clean_signal(up_clean)
  );
  debounce db_down(
    .clk(clk),
    .reset(reset),
    .noisy_signal(down),
    .clean_signal(down_clean)
  );
```
   - `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。
##### IV. 计时
```verilog
  wire [5:0] seconds, minutes, hours;
  Ktime timer(
    .one_hz_clk(one_hz_clk), .reset(reset), .set_mod(set_mod),
    .set_hours(set_hours), .set_minutes(set_minutes), .set_seconds(set_seconds),
    .seconds(seconds), .minutes(minutes),.hours(hours)  // 输出
  );
```
   - `seconds`, `minutes`, `hours`是计时模块的输出信号，分别代表秒、分钟和小时。
   - `Ktime`模块是一个计时器，它使用1Hz的时钟信号来递增秒数，并在秒数达到60时递增分钟数，分钟数达到60时递增小时数。
   - `set_mod`信号用于控制计时器是否进入设置模式，`set_hours`, `set_minutes`, `set_seconds`是设置模式下的时间值。
##### V. 时间设置
```verilog
wire [5:0] set_seconds, set_minutes, set_hours;
wire [2:0] pos;
timer_setting timer_setter(
  .clk(clk), .reset(reset), .set_mod(set_mod), .left(left_clean), .right(right_clean),
  .up(up_clean), .down(down_clean), .hours(hours), .minutes(minutes), .seconds(seconds),
  .set_hours(set_hours), .set_minutes(set_minutes), .set_seconds(set_seconds),  // out
  .pos(pos)
);
```
   - `set_seconds`, `set_minutes`, `set_hours`是设置模式下的时间值。
   - `pos`是一个3位的信号，用于指示当前设置的位置（小时、分钟或秒）。
   - `timer_setting`模块允许用户通过按钮调整时间，并在设置模式下更新`set_hours`, `set_minutes`, `set_seconds`的值。
##### VI. 时间显示
```verilog
timer_show timer_shower(
  .clk(clk), .hours(hours), .minutes(minutes), .seconds(seconds),
  .pos(pos), .set_mod(set_mod),
  .left_wei(sm_left_wei),  // 输出
  .left_duan(sm_left_duan),
  .right_wei(sm_right_wei),
  .right_duan(sm_right_duan)
);
```
   - `timer_show`模块负责将当前时间或设置的时间显示在数码管上。
   - 它接收时钟信号、小时、分钟、秒以及位置和设置模式信号，并输出数码管的位选和段选信号。
##### VII. 音频播放
```verilog
wire beep_w;
assign beep = (minutes == 0) & beep_w;
audio_player audio(
  .clk(clk),
  .beep(beep_w),
  .sd(sd)
);
```
   - `beep_w`是一个内部信号，用于控制蜂鸣器。
   - `beep`信号在分钟数为零时（整点）被激活。
   - `audio_player`模块接收时钟信号、蜂鸣器控制信号，并输出音频信号`sd`。

#### 去抖动模块 `module debounce`

1. **模块定义**：
   ```verilog
   module debounce(
     input clk,  // 100MHz
     input reset,
     input noisy_signal,
     output reg clean_signal
   );
   ```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
   ```verilog
   reg [20:0] counter;
   reg stable_signal;
   ```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
   ```verilog
   always @(posedge clk, negedge reset) begin
     if (~reset) begin
       counter <= 0;
       clean_signal <= 0;
       stable_signal <= 0;
     end else begin
       // ...
     end
   end
   ```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（低电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
   ```verilog
   if (noisy_signal == stable_signal) begin
     // 当输入信号与当前稳定信号相同时，增加计数器
     if (counter < 2000000)  // 等待大约20ms
       counter <= counter + 1;
     else
       clean_signal <= stable_signal;  // 更新输出信号
   end else begin
     // 如果输入信号改变，重置计数器并更新稳定信号
     counter <= 0;
     stable_signal <= noisy_signal;
   end
   ```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### 计数模块 `module counter`

1. **模块定义**：
   ```verilog
   module counter(
     input clk,
     input reset,
     input enable,
     input set,
     input [31:0] set_count,
     output reg [31:0] count,
     output reg carry_out
   );
   ```
- 这行代码定义了名为 `counter` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`reset` 是复位信号，`enable` 是使能信号，`set` 是设置信号，`set_count` 是设置的计数值，`count` 是当前计数值的输出，`carry_out` 是进位输出。
2. **参数定义**：
   ```verilog
   parameter MAX_COUNT = 59; // 默认最大计数值为 59
   ```
- 这个参数定义了计数器的最大计数值。
3. **时序逻辑**：
   ```verilog
   always @(posedge clk or posedge reset) begin
     if (reset) begin
       count <= 0;
       carry_out <= 0;
     end else if (set) begin
       count <= set_count;
       carry_out <= 0;
     end else if (enable) begin
       if (count == MAX_COUNT) begin
         count <= 0;
         carry_out <= 0;
       end else begin
         count <= count + 1;
         if(count == MAX_COUNT-1) begin  // 提前触发
           carry_out <= 1;
         end else begin
           carry_out <= 0;
         end
       end
     end else begin
       carry_out <= 0;
     end
   end
   ```
- 这个 `always` 块是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。如果复位信号被激活（高电平），则计数器和进位输出都被重置为 0。如果设置信号被激活（高电平），则计数器被设置为 `set_count` 的值，进位输出被重置为 0。如果使能信号被激活（高电平），则计数器递增，并且当计数器达到最大值时，计数器被重置为 0，进位输出也被重置为 0。如果计数器在达到最大值之前进位，进位输出被提前触发为 1。如果使能信号不被激活，进位输出被保持为 0。

这个模块通过简单的计数机制实现了计数功能，并且可以根据设置信号和使能信号来控制计数器的值和进位输出。


#### 计时模块 `module Ktime`

1. **模块定义**：
```verilog
module Ktime(
  input one_hz_clk,  // 1Hz时钟信号
  input reset,       // 复位信号
  input set_mod,     // 设置模式信号
  input [5:0] set_hours,  // 设置小时输入
  input [5:0] set_minutes,  // 设置分钟输入
  input [5:0] set_seconds,  // 设置秒输入
  output [5:0] seconds,  // 秒输出
  output [5:0] minutes,  // 分钟输出
  output [5:0] hours    // 小时输出
);
```
- 这个模块定义了时钟的基本输入和输出信号。
2. **内部连线**：
```verilog
wire sec_carry, min_carry;
```
- 这两个线是用来传递秒和分钟计数器的进位信号。
3. **计数器实例**：
```verilog
counter sec_counter (
  .clk(one_hz_clk), .reset(reset), .enable(1'b1),
  .set(set_mod),.set_count(set_seconds),.count(seconds), .carry_out(sec_carry)
);
```
- `sec_counter`：秒计数器，当设置模式激活时，可以设置秒数。
```verilog
counter min_counter (
  .clk(one_hz_clk), .reset(reset), .enable(sec_carry),
  .set(set_mod),.set_count(set_minutes),.count(minutes), .carry_out(min_carry)
);
```
- `min_counter`：分钟计数器，当秒计数器的进位信号有效时，可以设置分钟数。
```verilog
counter hour_counter(
    .clk(one_hz_clk), .reset(reset), .enable(min_carry),
    .set(set_mod),.set_count(set_hours), .count(hours)
  );
```
- `hour_counter`：小时计数器，当分钟计数器的进位信号有效时，可以设置小时数。
4. **参数重定义**：
```verilog
defparam hour_counter.MAX_COUNT = 23;
```
- 这个参数重定义了小时计数器的最大值，设置为 23，因为小时计数器只需要计数到 23。
5. **计数器模块**：
- 这三个计数器模块都是基于 `counter` 模块。这个 `counter` 模块是一个 32 位计数器，它可以在设置模式激活时被设置为指定的值。当计数器达到最大值时，它会自动重置为 0。此外，它还有一个提前触发的进位输出，当计数器接近最大值时，输出会提前变为 1。

`Ktime` 模块通过这三个计数器实例创建了一个级联时钟，其中秒计数器每秒递增，分钟计数器在秒计数器进位时递增，小时计数器在分钟计数器进位时递增。当设置模式激活时，计数器可以被设置为 `set_hours`、`set_minutes` 和 `set_seconds` 提供的值。

#### 时间设置模块 `module timer_setting`

1. **模块定义**：
```verilog
module timer_setting(
  input clk,  // 100MHz
  input reset,
  input set_mod,
  input left,
  input right,
  input up,
  input down,
  input [5:0] seconds,
  input [5:0] minutes,
  input [5:0] hours,
  output reg signed [32:0] set_hours,
  output reg signed [32:0] set_minutes,
  output reg signed [32:0] set_seconds,
  output reg [2:0] pos
);
```
- 这行代码定义了名为 `timer_setting` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`reset` 是复位信号，`set_mod` 是设置模式信号，`left`、`right`、`up` 和 `down` 是方向控制信号，`seconds`、`minutes` 和 `hours` 是当前时间的小时、分钟和秒，`set_hours`、`set_minutes` 和 `set_seconds` 是设置的时间的小时、分钟和秒，`pos` 指示当前设置的时间部分。
2. **保存前一个状态的寄存器**：
```verilog
reg left_prev;
reg right_prev;
reg up_prev;
reg down_prev;
```
- 这些寄存器用于保存前一个状态的 `left`、`right`、`up` 和 `down` 信号。
3. **方向控制逻辑**：
```verilog
always @(posedge clk or posedge reset) begin
  if (reset) begin
    pos <= 0;
    left_prev <= 0;
    right_prev <= 0;
  end else begin
    left_prev <= left;
    right_prev <= right;
    if (left && !left_prev && !right) begin
      if (pos == 5)
        pos <= 0;
      else
        pos <= pos + 1;
    end
    if (right && !right_prev && !left) begin
      if (pos == 0)
        pos <= 5;
      else
        pos <= pos - 1;
    end
  end
end
```
- 这个 `always` 块是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。它用于处理方向控制信号 `left` 和 `right`，并更新 `pos` 寄存器，指示当前设置的时间部分。
4. **时间设置逻辑**：
  ```verilog
  always @(posedge clk, posedge reset) begin
    if (reset) begin
      set_seconds <= 0;
      set_minutes <= 0;
      set_hours <= 0;
    end else if (set_mod) begin
      up_prev <= up;
      down_prev <= down;
      if (up && !up_prev && !down) begin
        case (pos)
          3'd0: set_seconds <= (set_seconds + 1) % 60;
          3'd1: set_seconds <= (set_seconds + 10) % 60;
          3'd2: set_minutes <= (set_minutes + 1) % 60;
          3'd3: set_minutes <= (set_minutes + 10) % 60;
          3'd4: set_hours   <= (set_hours + 1) % 24;
          3'd5: set_hours   <= (set_hours + 10) % 24;
        endcase
      
      end else if (down && !down_prev && !up) begin
        case (pos)
          3'd0: set_seconds <= (set_seconds - 1 + 60) % 60;
          3'd1: set_seconds <= (set_seconds - 10 + 60) % 60;
          3'd2: set_minutes <= (set_minutes - 1 + 60) % 60;
          3'd3: set_minutes <= (set_minutes - 10 + 60) % 60;
          3'd4: set_hours   <= (set_hours - 1 + 24) % 24;
          3'd5: set_hours   <= (set_hours - 10 + 24) % 24;
        endcase
      end
    end else if (~set_mod) begin
      set_hours <= hours;
      set_minutes <= minutes;
      set_seconds <= seconds;
    end
  end
  endmodule
```
- 这个 `always` 块也是一个时序逻辑块，它在时钟的上升沿或复位信号的上升沿触发。如果 `set_mod` 信号有效（高电平），则它将处理方向控制信号 `up` 和 `down`，并根据 `pos` 寄存器的值增加或减少时间。如果 `set_mod` 信号无效（低电平），则它将输出当前的时间值 `hours`、`minutes` 和 `seconds`。

这个模块通过处理方向控制信号和设置模式信号来允许用户设置时钟时间。当 `set_mod` 信号被激活时，用户可以通过按下 `up` 和 `down` 按钮来增加或减少时间。当 `set_mod` 信号被清除时，模块将输出当前设置的时间值。

#### 时间显示模块 `module timer_show`

这个 `timer_show` 模块是一个用于显示时钟时间的 Verilog 模块。它接收一个时钟信号 `clk`，当前时间的小时、分钟和秒，当前设置的时间部分 `pos`，设置模式信号 `set_mod`，以及输出信号到左边的数码管和右边的数码管。
以下是 `timer_show` 模块的详细分析：
1. **模块定义**：
```verilog
module timer_show(
  input clk,
  input [5:0]hours,
  input [5:0]minutes,
  input [5:0]seconds,
  input [2:0] pos,
  input set_mod,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan
);
```
- 这行代码定义了名为 `timer_show` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`hours`、`minutes` 和 `seconds` 是当前时间的小时、分钟和秒，`pos` 指示当前设置的时间部分，`set_mod` 是设置模式信号，`left_wei`、`left_duan`、`right_wei` 和 `right_duan` 是输出信号到左边的数码管和右边的数码管。
2. **分频逻辑**：
```verilog
reg clk_2Hz = 0;  // 1HZ
reg [32:0] counter_2Hz=0;
always @(posedge clk) begin
  if (counter_2Hz == 50000000/2-1) begin
    counter_2Hz<=0;
    clk_2Hz<=~clk_2Hz;
  end else counter_2Hz <= counter_2Hz+1;
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 2Hz 的时钟信号 `clk_2Hz`。
3. **闪烁逻辑**：
```verilog
wire [2:0] flash_pos;
reg[7:0] flash = 0;
always @(posedge clk_2Hz) begin
  if (set_mod) begin
    flash <= ~flash;
  end else begin
    flash <= ~(8'd0);
  end
end
wire [3:0] select_wei;
assign select_wei = 1 << flash_pos;
assign left_duan = (pos > 3 && select_wei == left_wei) ?
  (flash & sm_left_duan) : sm_left_duan;
assign right_duan = (pos <= 3 && select_wei == right_wei) ?
  (flash & sm_right_duan) : sm_right_duan;
```
- 这个部分用于控制数码管的闪烁。当 `set_mod` 信号有效时，数码管会闪烁；否则，数码管将不闪烁。
4. **获取段选信号和位选信号**：
```verilog
reg [15:0] left_data, right_data;
wire [3:0] hours_high, hours_low, minutes_high, minutes_low, seconds_high, seconds_low;
assign hours_high = hours/10;
assign hours_low = hours%10;
assign minutes_high = minutes/10;
assign minutes_low = minutes%10;
assign seconds_high = seconds/10;
assign seconds_low = seconds%10;
always @(posedge clk) begin
  left_data <= {hours_low,hours_high,{4'b1111},{4'b1111}};  // TODO(SJ): just test pos
  right_data <= {seconds_low,seconds_high,minutes_low,minutes_high};
end
```
- 这个部分用于将小时、分钟和秒转换为段选信号和位选信号，并输出到左边的数码管和右边的数码管。
5. **数码管显示模型**：
```verilog
smg_ip_model smg_left(
  .clk(clk), .data(left_data),
  .sm_wei(left_wei), .sm_duan(sm_left_duan)  // 位选信号不用处理，直接输出即可
);
smg_ip_model smg_right(
  .clk(clk), .data(right_data),
  .sm_wei(right_wei), .sm_duan(sm_right_duan)
);
```
- 这两个部分分别定义了左边的数码管和右边的数码管的显示模型。它们接收时钟信号 `clk`，段选信号 `sm_wei` 和位选信号 `sm_duan`，以及数据信号 `data`，并将其显示在数码管上。

这个模块通过处理时钟信号、当前时间、设置模式信号以及输入的数码管控制信号，来显示当前的时间。当 `set_mod` 信号有效时，数码管会显示设置的时间；否则，它会显示当前的时间。

#### 数码管显示模块 `module smg_ip_model`
1. **模块定义**：
```verilog
module smg_ip_model(clk,data,sm_wei,sm_duan);
```
- 定义了名为 `smg_ip_model` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`data` 是输入的数据信号，`sm_wei` 是位选信号，`sm_duan` 是段选信号。
2. **分频逻辑**：
```verilog
integer clk_cnt=0;
reg clk_1kHz=0;
always @(posedge clk) begin
  if(clk_cnt==32'd50000-1)
    begin clk_cnt <= 1'b0; clk_1kHz <= ~clk_1kHz;end
  else begin
    clk_cnt <= clk_cnt + 1'b1;
  end
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 1kHz 的时钟信号 `clk_1kHz`。
3. **位控制逻辑**：
```verilog
reg [3:0]wei_ctrl=4'b1110;
always @(posedge clk_1kHz) begin
  wei_ctrl <= {wei_ctrl[2:0],wei_ctrl[3]};  // 循环移位
end
```
- 这个部分用于控制位选信号 `sm_wei`。它将 `wei_ctrl` 寄存器的值进行循环移位，以产生不同的位选信号。
4. **段控制逻辑**：
```verilog
reg [3:0]duan_ctrl;
always @(posedge clk) begin
  case(wei_ctrl)
    // ...
  default : duan_ctrl=4'hf;
  endcase
end
```
- 这个部分用于控制段选信号 `sm_duan`。它根据位选信号 `wei_ctrl` 的值，选择相应的段选信号 `duan_ctrl`，并将它输出到 `sm_duan`。
5. **解码模块**：
```verilog
reg [7:0]duan;
always @(posedge clk) begin
  case(duan_ctrl)
    // ...
  default : duan = 8'b0000_0000;//none
  endcase
end
```
- 这个部分用于解码段选信号 `duan_ctrl`，并输出相应的段选信号 `duan`。
6. **输出信号**：
```verilog
assign sm_wei =~wei_ctrl;
assign sm_duan = duan;
```
- 这两个部分分别将位选信号 `wei_ctrl` 和段选信号 `duan` 输出到 `sm_wei` 和 `sm_duan`。

这个模块通过处理时钟信号、输入的数据信号和位选信号，来输出相应的段选信号，从而控制数码管显示不同的数字或符号。

#### 音频播放模块 `module audio_player`

1. **模块定义**：
```verilog
module audio_player(
  input clk,
  output beep, // 蜂鸣器输出
  output sd
);
```
- 定义名为 `audio_player` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`beep` 是蜂鸣器控制信号，`sd` 是 SD卡控制信号。
2. **内部寄存器**：
```verilog
reg beep_r;
reg[7:0] state;  // 乐谱状态机
reg[16:0] count, pre_number;
reg[25:0] beat_time;
```
- 这些寄存器用于存储和控制音频播放的状态和计数。
3. **输出信号**：
```verilog
assign sd = 1'b1;
```
- 这个部分将 SD 卡控制信号 `sd` 固定为高电平。
4. **参数定义**：
```verilog
parameter L_1 = 18'd127552,  // 低音1
  L_2 = 18'd113636,  // 低音2
  L_3 = 18'd101236,  // 低音3
  L_4 = 18'd95548,  // 低音4
  L_5 = 18'd85136,  // 低音5
  L_6 = 18'd75838,  // 低音6
  L_7 = 18'd67567,  // 低音7
  M_1 = 18'd63776,  // 中音1
  M_2 = 18'd56818,  // 中音2
  M_3 = 18'd50607,  // 中音3
  M_4 = 18'd47778,  // 中音4
  M_5 = 18'd42553,  // 中音5
  M_6 = 18'd37936,  // 中音6
  M_7 = 18'd33783;  // 中音7
parameter TIME = 50000000; // 每种音阶持续时长为500ms
```
- 这些参数定义了乐谱中不同音符的频率和持续时长。
5. **蜂鸣器控制逻辑**：
```verilog
assign beep = beep_r;
```
- 这个部分将蜂鸣器控制信号 `beep` 设置为 `beep_r` 的值。
6. **计数器逻辑**：
```verilog
always @(posedge clk) begin
  count <= count + 1'b1;
  if(count == pre_number) begin
    count <= 17'h0;
    beep_r <= !beep_r;  // 实际上每个周期分别包括等时长的高电位和低电位，一高一低反复循环，形成不同频率的声音
  end
end
```
- 这个部分用于控制蜂鸣器的频率。它通过计数器 `count` 来控制蜂鸣器的高低电平持续时间。
7. **乐谱状态机逻辑**：
```verilog
always @(posedge clk) begin
  if(beat_time < TIME)
    beat_time = beat_time + 1'b1;
  else begin
    beat_time = 26'd0;
    if(state == 8'd13)
      state = 8'd0;
    else
      state = state + 1'b1;
  case(state)
    32'D0:pre_number = 0;
    32'D1:pre_number = 0;
    32'D2:pre_number = M_5;
    32'D3:pre_number = 0;
    32'D4:pre_number = M_5;
    32'D5:pre_number = M_5;
    32'D6:pre_number = M_1;
    32'D7:pre_number = 0;
    32'D8:pre_number = M_1;
    32'D9:pre_number = M_1;
    32'D10:pre_number = M_1;
    32'D11:pre_number = M_1;
    32'D12:pre_number = M_2; // 重复一次re
    32'D13:pre_number = M_2; // 重复一次re
    32'D14:pre_number = M_3; // 重复一次mi
    32'D15:pre_number = M_3; // 重复一次mi
    // Continue from previous numbering
    32'D16:pre_number = 0;
    32'D17:pre_number = 0; // 重复两次停顿
    32'D18:pre_number = M_5;
    32'D19:pre_number = 0;
    32'D20:pre_number = M_5;
    32'D21:pre_number = M_5;
    32'D22:pre_number = M_1;
    32'D23:pre_number = 0;
    32'D24:pre_number = M_1;
    32'D25:pre_number = M_1;
    32'D26:pre_number = M_2; // 重复一次re
    32'D27:pre_number = M_3; // 重复一次mi
    32'D28:pre_number = M_2; // 重复一次re
    32'D29:pre_number = M_1; // 重复一次do
    32'D30:pre_number = L_5; // 重复一次so
    32'D31:pre_number = L_5; // 重复一次so
    // Assume prior commands reached 32'D31, continue from 32'D32
    32'D32:pre_number = 0; // 停顿
    32'D33:pre_number = 0; // 重复停顿
    32'D34:pre_number = M_5; // 中音so
    32'D35:pre_number = M_5; // 重复中音so
    32'D36:pre_number = M_1; // 中音do
    32'D37:pre_number = M_1; // 重复中音do
    32'D38:pre_number = M_1; // 中音do
    32'D39:pre_number = M_1; // 重复中音do
    32'D40:pre_number = M_2; // 中音re
    32'D41:pre_number = M_2; // 重复中音re
    32'D42:pre_number = M_3; // 中音mi
    32'D43:pre_number = M_3; // 重复中音mi
    // Additional commands to follow sequence
    32'D44:pre_number = M_3; // 中音mi
    32'D45:pre_number = M_3; // 重复中音mi
    32'D46:pre_number = M_2; // 中音re
    32'D47:pre_number = M_2; // 重复中音re
    32'D48:pre_number = M_1; // 中音do
    32'D49:pre_number = M_1; // 重复中音do
    32'D50:pre_number = L_5; // 中音so
    32'D51:pre_number = L_5; // 重复中音so
    32'D52:pre_number = M_1; // 中音do
    32'D53:pre_number = M_1; // 重复中音do
    32'D54:pre_number = M_2; // 中音re
    32'D55:pre_number = M_2; // 重复中音re
    32'D56:pre_number = M_3; // 中音mi
    32'D57:pre_number = M_3; // 重复中音mi
    32'D58:pre_number = M_4; // 中音fa
    32'D59:pre_number = M_4; // 重复中音fa
    32'D60:pre_number = M_3; // 中音mi
    32'D61:pre_number = M_3; // 重复中音mi
    32'D62:pre_number = M_2; // 中音re
    32'D63:pre_number = M_2; // 重复中音re
    32'D64:pre_number = L_1; // 低音do
    32'D65:pre_number = M_2; // 重复中音re
    32'D66:pre_number = M_3; // 中音mi
    32'D67:pre_number = 0; // 停顿
    32'D68:pre_number = M_3; // 重复中音mi
    32'D69:pre_number = 0; // 停顿
    32'D70:pre_number = M_3; // 重复中音mi
    32'D71:pre_number = 0; // 停顿
    32'D72:pre_number = M_3; // 重复中音mi
    32'D73:pre_number = M_3; // 重复中音mi
    32'D74:pre_number = M_2; // 中音re
    32'D75:pre_number = M_3; // 中音mi
    32'D76:pre_number = M_2; // 中音re
    32'D77:pre_number = M_2; // 重复中音re
    32'D78:pre_number = M_1; // 中音do
    32'D79:pre_number = M_1; // 重复中音do
    32'D80:pre_number = M_1; // 中音do
    32'D81:pre_number = M_1; // 重复中音do
    32'D82:pre_number = L_5; // 中音so
    32'D83:pre_number = L_5; // 中音so
    32'D84:pre_number = M_1; // 中音do
    32'D85:pre_number = M_1; // 中音do
    32'D86:pre_number = M_2; // 中音re
    32'D87:pre_number = M_2; // 重复中音re
    32'D88:pre_number = M_3; // 中音mi
    32'D89:pre_number = M_3; // 重复中音mi
    32'D90:pre_number = M_4; // 中音fa
    32'D91:pre_number = M_4; // 重复中音fa
    32'D92:pre_number = M_3; // 中音mi
    32'D93:pre_number = M_3; // 重复中音mi
    32'D94:pre_number = M_2; // 中音re
    32'D95:pre_number = M_2; // 重复中音re
    32'D96:pre_number = L_1; // 低音do
    32'D97:pre_number = M_2; // 重复中音re
    32'D98:pre_number = M_3; // 中音mi
    32'D99:pre_number = 0; // 停顿
    32'D100:pre_number = M_3; // 重复中音mi
    32'D101:pre_number = 0; // 停顿
    32'D102:pre_number = M_3; // 重复中音mi
    32'D103:pre_number = 0; // 停顿
    32'D104:pre_number = M_3; // 重复中音mi
    32'D105:pre_number = M_3; // 重复中音mi
    32'D106:pre_number = M_2; // 中音re
    32'D107:pre_number = M_3; // 中音mi
    32'D108:pre_number = M_2; // 中音re
    32'D109:pre_number = M_2; // 重复中音re
    32'D110:pre_number = M_1; // 中音do
    32'D111:pre_number = M_1; // 重复中音do
    32'D112:pre_number = M_1; // 中音do
    32'D113:pre_number = M_1; // 重复中音do
    default: pre_number = 32'h0;
   endcase
  end
end
```
- 这个部分用于控制乐谱的播放。它通过状态机 `state` 来选择不同的音符，并通过计数器 `beat_time` 来控制每个音符的持续时长。当 `beat_time` 达到预设的时长 `TIME` 时，状态机 `state` 自动切换到下一个音符，并重置 `beat_time`。

这个模块通过时钟信号 `clk` 控制蜂鸣器的频率和乐谱的播放。当蜂鸣器频率改变时，它会发出不同的音调；当乐谱状态机切换到下一个音符时，它会播放不同的音阶。

#### 管脚分配

本组直接通过编写`clock.xdc`约束文件来完成引脚分配。

以下是`clock.xdc`的引脚和信号分配的表格：

| 信号                | 引脚  | IOSTANDARD |
|---------------------|-------|------------|
| clk                 | P17   | LVCMOS33   |
| reset               | R1    | LVCMOS33   |
| down                | R17   | LVCMOS33   |
| left                | V1    | LVCMOS33   |
| right               | R11   | LVCMOS33   |
| up                  | U4    | LVCMOS33   |
| set_mod             | N4    | LVCMOS33   |
| beep                | T1    | LVCMOS33   |
| sd                  | M6    | LVCMOS33   |
| sm_left_duan[0]     | B4    | LVCMOS33   |
| sm_left_duan[1]     | A4    | LVCMOS33   |
| sm_left_duan[2]     | A3    | LVCMOS33   |
| sm_left_duan[3]     | B1    | LVCMOS33   |
| sm_left_duan[4]     | A1    | LVCMOS33   |
| sm_left_duan[5]     | B3    | LVCMOS33   |
| sm_left_duan[6]     | B2    | LVCMOS33   |
| sm_left_duan[7]     | D5    | LVCMOS33   |
| sm_right_duan[0]    | D4    | LVCMOS33   |
| sm_right_duan[1]    | E3    | LVCMOS33   |
| sm_right_duan[2]    | D3    | LVCMOS33   |
| sm_right_duan[3]    | F4    | LVCMOS33   |
| sm_right_duan[4]    | F3    | LVCMOS33   |
| sm_right_duan[5]    | E2    | LVCMOS33   |
| sm_right_duan[6]    | D2    | LVCMOS33   |
| sm_right_duan[7]    | H2    | LVCMOS33   |
| sm_left_wei[0]      | G2    | LVCMOS33   |
| sm_left_wei[1]      | C2    | LVCMOS33   |
| sm_left_wei[2]      | C1    | LVCMOS33   |
| sm_left_wei[3]      | H1    | LVCMOS33   |
| sm_right_wei[0]     | G1    | LVCMOS33   |
| sm_right_wei[1]     | F1    | LVCMOS33   |
| sm_right_wei[2]     | E1    | LVCMOS33   |
| sm_right_wei[3]     | G6    | LVCMOS33   |

此外，还有以下组合逻辑允许的属性设置：
- `ALLOW_COMBINATORIAL_LOOPS TRUE [get_nets timer_setter/p_1_in[2]]`
- `ALLOW_COMBINATORIAL_LOOPS TRUE [get_nets timer_setter/left_data[6]_i_2]`


### 调试过程中的问题及讨论

- 时间无法正常显示

  - 问题描述：在实现时间显示时，发现使劲按无法正常显示。

  - 问题分析：可能是由于时间显示模块的逻辑错误导致时间无法正常显示。

  - 解决方案：检查 `timer_show` 模块的逻辑，确保其正确性。

- 时间设置功能出现问题

  - 问题描述：在实现时间设置功能时，发现时间设置功能无法正常工作。

  - 问题分析：可能是与系统的时钟不同步。

  - 解决方案：修改代码，添加始终同步机制。

- 音频工作效果不佳

  - 问题描述：在实现音频功能时，发现音频工作效果不佳。

  - 问题分析：可能是由于音频过于单一。

  - 解决方案：添加了乐谱状态机。

- 有时按键抖动

  - 问题描述：在按键按下时，有时会出现按键抖动的情况。

  - 问题分析：机械开关接触不良等原因产生的短暂信号跳变。

  - 解决方案：添加去抖动模块 `debounce`。

### 设计调试小结

- 设计小结：我们的设计分为多模块，每个模块都实现了特定的功能。通过模块之间的协同工作，实现了整个系统的功能。

- 在实现过程中，遇到了许多问题，例如时间无法正常显示、时间设置功能出现问题、音频工作效果不佳等。这些问题需要我们仔细检查代码，并尝试解决。

- 在调试过程中，我们发现了一些可以优化的地方，例如可以添加更多的注释来解释代码逻辑。

- 我们在课程设计的代码中采用了分模块的方式，这会使我们分工明确，使我们的调试能够精准定位，十分方便。

## B. 药片装瓶系统设计

### 题目分析

#### 原题目要求

- 基本功能：实现药片装瓶功能；能够同时显示药瓶以及药片数量；有工作状态以及告警指示；有清零状态、设置状态和工作状态，实现状态间正确切换设置。

- 附加功能：实现设置状态时闪烁显示、工作状态时可以切换显示初始设置、可以设定每瓶药片数以及总药片数量限定等等。

#### 小组题目分析

本题目要求设计一个基于FPGA的药片装瓶系统，包括基本功能和附加功能。
1. 基本功能：
- 实现药片装瓶功能：需要设计一个能够模拟药片装瓶过程的系统，可以检测药片的数量，并将其装入药瓶中。
- 能够同时显示药瓶以及药片数量：需要设计一个显示系统，能够同时显示当前药瓶的数量和每个药瓶中的药片数量。
- 有工作状态以及告警指示：需要设计一个工作状态指示灯，以及一个告警指示灯，用于指示系统的工作状态和告警状态。
- 有清零状态、设置状态和工作状态，实现状态间正确切换设置：需要设计一个状态机，能够实现清零状态、设置状态和工作状态之间的正确切换。
2. 附加功能：
- 实现设置状态时闪烁显示：需要设计一个在设置状态下，显示系统会闪烁的机制，以便用户知道当前处于设置状态。
- 工作状态时可以切换显示初始设置：需要设计一个在工作状态下，可以切换显示初始设置的机制，以便用户可以查看初始设置信息。
- 可以设定每瓶药片数以及总药片数量限定：需要设计一个设置功能，可以设定每瓶药片的数量以及总药片数量的限定，以便用户可以根据需要进行设置。

### 设计详解

#### 顶层模块 `module tabletFillingMachine`

##### I. 顶层模块 `module tabletFillingMachine`的输入输出

```verilog
module tabletFillingMachine(
  input clk,
  input reset,
  input set,
  input fill,
  input left,
  input right,
  input up,
  input down,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan,
  output beep,
  output sd
);
```

1. **输入信号**:
   - `clk`: 100MHz的时钟输入。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `set`: 设置模式输入，用于进入设置模式。
   - `fill`: 填充信号，表示药片填充操作正在进行。
   - `left`, `right`, `up`, `down`: 四个按钮输入，用于在设置模式中导航。
2. **输出信号**:
   - `sm_left_wei` 和 `sm_left_duan`: 左边数码管的位选和段选信号。
   - `sm_right_wei` 和 `sm_right_duan`: 右边数码管的位选和段选信号。
   - `beep`: 蜂鸣器输出，用于发出声音提示。
   - `sd`: 音频输出，与`beep`一起用于发出更复杂的音频提示。

##### II. 状态定义
```verilog
reg[1:0] IDLE = 2'b00, SETTING = 2'b01, WORKING = 2'b10, ALARM = 2'b11;
reg[1:0] state = 2'b10;
reg[31:0] TABLET_CNT_SUM = 32'd20, CAPACITY = 32'd9;
reg[31:0] tablet_cnt = 32'd0, bottle_cnt = 32'd0;
```
   - `IDLE`, `SETTING`, `WORKING`, `ALARM`是状态寄存器，用于表示机器的不同状态。
   - `TABLET_CNT_SUM`和`bottle_cnt`是计数器，分别用于记录总的药片数量和当前药瓶的药片数量。
   - `tablet_cnt`是当前填充的药片数量，`CAPACITY`是药瓶容量。

##### III. 去抖动
```verilog 
wire fill_clean;
debounce db_fill(
  .clk(clk), .reset(reset), .noisy_signal(fill),
  .clean_signal(fill_clean)
);
wire left_clean, right_clean, up_clean, down_clean;
debounce db_left(
  .clk(clk),
  .reset(reset),
  .noisy_signal(left),
  .clean_signal(left_clean)
);
debounce db_right(
  .clk(clk),
  .reset(reset),
  .noisy_signal(right),
  .clean_signal(right_clean)
);
debounce db_up(
  .clk(clk),
  .reset(reset),
  .noisy_signal(up),
  .clean_signal(up_clean)
);
debounce db_down(
  .clk(clk),
  .reset(reset),
  .noisy_signal(down),
  .clean_signal(down_clean)
);
```
   - `fill_clean`, `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。

##### IV. 状态转换
```verilog
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    state <= WORKING;
  end else begin
    if ((tablet_cnt + bottle_cnt * CAPACITY >= TABLET_CNT_SUM) ||
        (CAPACITY > 999) || (TABLET_CNT_SUM > 99) ||
        (tablet_cnt > 999) || (bottle_cnt > 999)
    ) begin
        state <= ALARM;
    end else if (set) begin
        state <= SETTING;  // 状态转换
    end else begin
        state <= WORKING;
    end
  end
end
```
- `always @(posedge clk, negedge reset)`块用于状态转换。
- 当满足某些条件（如药片和药瓶计数超过设定值）时，机器进入`ALARM`状态。
- 当`set`信号被激活时，机器进入`SETTING`状态。
- 其他情况下，机器保持在`WORKING`状态。
##### V. 药片填充
```verilog
reg fill_pre = 0;
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    tablet_cnt <= 0;
    bottle_cnt <= 0;
  end else if (state == WORKING) begin
    fill_pre <= fill_clean;
    if (fill_clean && !fill_pre) begin
      if (tablet_cnt == CAPACITY-1) begin
        bottle_cnt <= bottle_cnt + 1;
        tablet_cnt <= 0;
      end else begin
        tablet_cnt <= tablet_cnt + 1;
      end
    end
  end
end
```
- `always @(posedge clk, negedge reset)`块用于药片填充。
- `fill_pre`是填充信号的前一个值。
- 当检测到填充信号的上升沿时，如果当前药瓶的药片数量达到设定的容量，则增加药瓶计数并重置药片计数。否则，只增加药片计数。

##### VI. 设置模式
```verilog
reg[2:0] pos;
reg left_pre, right_pre, up_pre, down_pre;
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    pos <= 0;
  end else if (state == SETTING) begin
    left_pre <= left_clean;
    right_pre <= right_clean;
    up_pre <= up_clean;
    down_pre <= down_clean;
    if (left_clean && !left_pre) begin
      pos <= pos+1;
    end else if (right_clean && !right_pre) begin
      pos <= pos-1;
    end else if (up_clean && !up_pre) begin
      case(pos)
        3'd0: TABLET_CNT_SUM <= TABLET_CNT_SUM+1;
        3'd1: TABLET_CNT_SUM <= TABLET_CNT_SUM+10;
        3'd2: TABLET_CNT_SUM <= TABLET_CNT_SUM+100;
        // 3'd3: TABLET_CNT_SUM <= TABLET_CNT_SUM+1000;
        3'd4: CAPACITY <= CAPACITY + 1;
        3'd5: CAPACITY <= CAPACITY + 10;
        3'd6: CAPACITY <= CAPACITY + 100;
        // 3'd7: CAPACITY <= CAPACITY + 1000;
        default:;
      endcase
    end else if (down_clean && !down_pre) begin
      case(pos)
        3'd0: TABLET_CNT_SUM <= TABLET_CNT_SUM-1;
        3'd1: TABLET_CNT_SUM <= TABLET_CNT_SUM-10;
        3'd2: TABLET_CNT_SUM <= TABLET_CNT_SUM-100;
        // 3'd3: TABLET_CNT_SUM <= TABLET_CNT_SUM-1000;
        3'd4: CAPACITY <= CAPACITY - 1;
        3'd5: CAPACITY <= CAPACITY - 10;
        3'd6: CAPACITY <= CAPACITY - 100;
        // 3'd7: CAPACITY <= CAPACITY - 1000;
      endcase
    end
  end
end
```
- `pos`是一个3位的信号，用于指示当前设置的位置。根据`pos`的值，可以修改`TABLET_CNT_SUM`（总药片数量）和`CAPACITY`（每瓶药片数）。修改值的选择是基于`pos`的值，例如，`TABLET_CNT_SUM`可以增加1、10或100，而`CAPACITY`可以增加1、10或100。
- `always @(posedge clk, negedge reset)`块用于设置操作。
- 通过按钮操作，用户可以增加或减少总药片数量和药瓶的容量。

##### VII. 显示
```verilog
wire[31:0]tablet_cnt_show, bottle_cnt_show;
assign tablet_cnt_show = set ? TABLET_CNT_SUM : tablet_cnt;
assign bottle_cnt_show = set ? CAPACITY : bottle_cnt;
tablet_show shower(
  .clk(clk),
  .tablet_cnt(tablet_cnt_show),
  .bottle_cnt(bottle_cnt_show),
  .pos(pos),
  .set_mod(set),
  .left_wei(left_wei),  // 左边的数码管
  .left_duan(left_duan),  //
  .right_wei(right_wei),  //
  .right_duan(right_duan)
);
```
- `tablet_cnt_show`和`bottle_cnt_show`是显示信号，分别显示总的药片数量和当前药瓶的药片数量。 
- `tablet_show`模块负责将当前显示信号显示在数码管上。
##### VIII. 音频播放
```verilog
wire beep_w;
assign beep = (state == ALARM) & beep_w;
audio_player audio(
  .clk(clk),
  .beep(beep_w),
  .sd(sd)
);
```
   - `beep_w`是一个内部信号，用于控制蜂鸣器。 
   - `beep`信号在机器进入`ALARM`状态时被激活。 
   - `audio_player`模块接收时钟信号、蜂鸣器控制信号，并输出音频信号`sd`。

#### 去抖动模块 `module debounce`

1. **模块定义**：
```verilog
module debounce(
  input clk,  // 100MHz
  input reset,
  input noisy_signal,
  output reg clean_signal
);
```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
```verilog
reg [20:0] counter;
reg stable_signal;
```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
```verilog
always @(posedge clk, negedge reset) begin
  if (~reset) begin
    counter <= 0;
    clean_signal <= 0;
    stable_signal <= 0;
  end else begin
    // ...
  end
end
```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（低电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
```verilog
if (noisy_signal == stable_signal) begin
  // 当输入信号与当前稳定信号相同时，增加计数器
  if (counter < 2000000)  // 等待大约20ms
    counter <= counter + 1;
  else
    clean_signal <= stable_signal;  // 更新输出信号
end else begin
  // 如果输入信号改变，重置计数器并更新稳定信号
  counter <= 0;
  stable_signal <= noisy_signal;
end
```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过简单的计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### 数码管显示模块 `module smg_ip_model`
1. **模块定义**：
```verilog
module smg_ip_model(clk,data,sm_wei,sm_duan);
```
- 定义了名为 `smg_ip_model` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`data` 是输入的数据信号，`sm_wei` 是位选信号，`sm_duan` 是段选信号。
2. **分频逻辑**：
```verilog
integer clk_cnt=0;
reg clk_1kHz=0;
always @(posedge clk) begin
  if(clk_cnt==32'd50000-1)
    begin clk_cnt <= 1'b0; clk_1kHz <= ~clk_1kHz;end
  else begin
    clk_cnt <= clk_cnt + 1'b1;
  end
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 1kHz 的时钟信号 `clk_1kHz`。
3. **位控制逻辑**：
```verilog
reg [3:0]wei_ctrl=4'b1110;
always @(posedge clk_1kHz) begin
  wei_ctrl <= {wei_ctrl[2:0],wei_ctrl[3]};  // 循环移位
end
```
- 这个部分用于控制位选信号 `sm_wei`。它将 `wei_ctrl` 寄存器的值进行循环移位，以产生不同的位选信号。
4. **段控制逻辑**：
```verilog
reg [3:0]duan_ctrl;
always @(posedge clk) begin
  case(wei_ctrl)
    // ...
  default : duan_ctrl=4'hf;
  endcase
end
```
- 这个部分用于控制段选信号 `sm_duan`。它根据位选信号 `wei_ctrl` 的值，选择相应的段选信号 `duan_ctrl`，并将它输出到 `sm_duan`。
5. **解码模块**：
```verilog
reg [7:0]duan;
always @(posedge clk) begin
  case(duan_ctrl)
    // ...
  default : duan = 8'b0000_0000;//none
  endcase
end
```
- 这个部分用于解码段选信号 `duan_ctrl`，并输出相应的段选信号 `duan`。
6. **输出信号**：
```verilog
assign sm_wei =~wei_ctrl;
assign sm_duan = duan;
```
- 这两个部分分别将位选信号 `wei_ctrl` 和段选信号 `duan` 输出到 `sm_wei` 和 `sm_duan`。

这个模块通过处理时钟信号、输入的数据信号和位选信号，来输出相应的段选信号，从而控制数码管显示不同的数字或符号。

#### 显示模块 `module tablet_show`

1. **模块定义**：
```verilog
module tablet_show(
  input clk,
  input [31:0] tablet_cnt,
  input [31:0] bottle_cnt,
  input [2:0] pos,
  input set_mod,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan
);
```
- 这行代码定义了名为 `tablet_show` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`tablet_cnt` 和 `bottle_cnt` 分别是药片计数和药瓶计数，`pos` 指示当前设置的时间部分，`set_mod` 是设置模式信号，`left_wei`、`left_duan`、`right_wei` 和 `right_duan` 是输出信号到左边的数码管和右边的数码管。
2. **分频逻辑**：
```verilog
reg clk_2Hz = 0;  // 1HZ
reg [32:0] counter_2Hz=0;
always @(posedge clk) begin
  if (counter_2Hz == 50000000/2-1) begin
    counter_2Hz<=0;
    clk_2Hz<=~clk_2Hz;
  end else counter_2Hz <= counter_2Hz+1;
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 2Hz 的时钟信号 `clk_2Hz`。
3. **闪烁逻辑**：
```verilog
wire [2:0] flash_pos;
reg[7:0] flash = 0;
always @(posedge clk_2Hz) begin
  if (set_mod) begin
    flash <= ~flash;
  end else begin
    flash <= ~(8'd0);
  end
end
wire [3:0] select_wei;
assign select_wei = 1 << flash_pos;
assign left_duan = (pos > 3 && select_wei == left_wei) ?
  (flash & sm_left_duan) : sm_left_duan;
assign right_duan = (pos <= 3 && select_wei == right_wei) ?
  (flash & sm_right_duan) : sm_right_duan;
```
- 这个部分用于控制数码管的闪烁。当 `set_mod` 信号有效时，数码管会闪烁；否则，数码管将不闪烁。
4. **获取段选信号和位选信号**：
```verilog
reg [15:0] left_data, right_data;
wire [3:0] bottle_hundreds, bottle_tens, bottle_units;
wire [3:0] tablet_hundreds, tablet_tens, tablet_units;
// 解码每个计数的各个位
assign bottle_hundreds  = (bottle_cnt / 100) % 10;
assign bottle_tens      = (bottle_cnt / 10) % 10;
assign bottle_units     = bottle_cnt % 10;
assign tablet_hundreds  = (tablet_cnt / 100) % 10;
assign tablet_tens      = (tablet_cnt / 10) % 10;
assign tablet_units     = tablet_cnt % 10;
always @(posedge clk) begin
  left_data <= {
    bottle_units, bottle_tens,
    bottle_hundreds, 4'Hf
  };
  right_data <= {
    tablet_units, tablet_tens,
    tablet_hundreds, 4'Hf
  };
end
```
- 这个部分用于将药片计数和药瓶计数转换为段选信号和位选信号，并输出到左边的数码管和右边的数码管。
5. **数码管显示模型**：
```verilog
smg_ip_model smg_left(
  .clk(clk), .data(left_data),
  .sm_wei(left_wei), .sm_duan(sm_left_duan)  // 位选信号不用处理，直接输出即可
);
smg_ip_model smg_right(
  .clk(clk), .data(right_data),
  .sm_wei(right_wei), .sm_duan(sm_right_duan)
);
```
- 这两个部分分别定义了左边的数码管和右边的数码管的显示模型。它们接收时钟信号 `clk`，段选信号 `sm_wei` 和位选信号 `sm_duan`，以及数据信号 `data`，并将其显示在数码管上。

这个模块通过处理时钟信号、药片计数、药瓶计数、设置模式信号以及输入的数码管控制信号，来显示当前的药片计数和药瓶计数。当 `set_mod` 信号有效时，数码管会显示设置的计数；否则，它会显示当前的计数。

#### 音频播放模块 `module audio_player`

1. **模块定义**：
```verilog
module audio_player(
  input clk,
  output beep, // 蜂鸣器输出
  output sd
);
```
- 定义名为 `audio_player` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`beep` 是蜂鸣器控制信号，`sd` 是 SD卡控制信号。
2. **内部寄存器**：
```verilog
reg beep_r;
reg[7:0] state;  // 乐谱状态机
reg[16:0] count, pre_number;
reg[25:0] beat_time;
```
- 这些寄存器用于存储和控制音频播放的状态和计数。
3. **输出信号**：
```verilog
assign sd = 1'b1;
```
- 这个部分将 SD 卡控制信号 `sd` 固定为高电平。
4. **参数定义**：
```verilog
parameter L_1 = 18'd127552,  // 低音1
  L_2 = 18'd113636,  // 低音2
  L_3 = 18'd101236,  // 低音3
  L_4 = 18'd95548,  // 低音4
  L_5 = 18'd85136,  // 低音5
  L_6 = 18'd75838,  // 低音6
  L_7 = 18'd67567,  // 低音7
  M_1 = 18'd63776,  // 中音1
  M_2 = 18'd56818,  // 中音2
  M_3 = 18'd50607,  // 中音3
  M_4 = 18'd47778,  // 中音4
  M_5 = 18'd42553,  // 中音5
  M_6 = 18'd37936,  // 中音6
  M_7 = 18'd33783;  // 中音7
parameter TIME = 50000000; // 每种音阶持续时长为500ms
```
- 这些参数定义了乐谱中不同音符的频率和持续时长。
5. **蜂鸣器控制逻辑**：
```verilog
assign beep = beep_r;
```
- 这个部分将蜂鸣器控制信号 `beep` 设置为 `beep_r` 的值。
6. **计数器逻辑**：
```verilog
always @(posedge clk) begin
  count <= count + 1'b1;
  if(count == pre_number) begin
    count <= 17'h0;
    beep_r <= !beep_r;  // 实际上每个周期分别包括等时长的高电位和低电位，一高一低反复循环，形成不同频率的声音
  end
end
```
- 这个部分用于控制蜂鸣器的频率。它通过计数器 `count` 来控制蜂鸣器的高低电平持续时间。
7. **乐谱状态机逻辑**：
```verilog
always @(posedge clk) begin
  if(beat_time < TIME)
    beat_time = beat_time + 1'b1;
  else begin
    beat_time = 26'd0;
    if(state == 8'd13)
      state = 8'd0;
    else
      state = state + 1'b1;
  case(state)
    32'D0:pre_number = 0;
    32'D1:pre_number = 0;
    32'D2:pre_number = M_5;
    32'D3:pre_number = 0;
    32'D4:pre_number = M_5;
    32'D5:pre_number = M_5;
    32'D6:pre_number = M_1;
    32'D7:pre_number = 0;
    32'D8:pre_number = M_1;
    32'D9:pre_number = M_1;
    32'D10:pre_number = M_1;
    32'D11:pre_number = M_1;
    32'D12:pre_number = M_2; // 重复一次re
    32'D13:pre_number = M_2; // 重复一次re
    32'D14:pre_number = M_3; // 重复一次mi
    32'D15:pre_number = M_3; // 重复一次mi
    // Continue from previous numbering
    32'D16:pre_number = 0;
    32'D17:pre_number = 0; // 重复两次停顿
    32'D18:pre_number = M_5;
    32'D19:pre_number = 0;
    32'D20:pre_number = M_5;
    32'D21:pre_number = M_5;
    32'D22:pre_number = M_1;
    32'D23:pre_number = 0;
    32'D24:pre_number = M_1;
    32'D25:pre_number = M_1;
    32'D26:pre_number = M_2; // 重复一次re
    32'D27:pre_number = M_3; // 重复一次mi
    32'D28:pre_number = M_2; // 重复一次re
    32'D29:pre_number = M_1; // 重复一次do
    32'D30:pre_number = L_5; // 重复一次so
    32'D31:pre_number = L_5; // 重复一次so
    // Assume prior commands reached 32'D31, continue from 32'D32
    32'D32:pre_number = 0; // 停顿
    32'D33:pre_number = 0; // 重复停顿
    32'D34:pre_number = M_5; // 中音so
    32'D35:pre_number = M_5; // 重复中音so
    32'D36:pre_number = M_1; // 中音do
    32'D37:pre_number = M_1; // 重复中音do
    32'D38:pre_number = M_1; // 中音do
    32'D39:pre_number = M_1; // 重复中音do
    32'D40:pre_number = M_2; // 中音re
    32'D41:pre_number = M_2; // 重复中音re
    32'D42:pre_number = M_3; // 中音mi
    32'D43:pre_number = M_3; // 重复中音mi
    // Additional commands to follow sequence
    32'D44:pre_number = M_3; // 中音mi
    32'D45:pre_number = M_3; // 重复中音mi
    32'D46:pre_number = M_2; // 中音re
    32'D47:pre_number = M_2; // 重复中音re
    32'D48:pre_number = M_1; // 中音do
    32'D49:pre_number = M_1; // 重复中音do
    32'D50:pre_number = L_5; // 中音so
    32'D51:pre_number = L_5; // 重复中音so
    32'D52:pre_number = M_1; // 中音do
    32'D53:pre_number = M_1; // 重复中音do
    32'D54:pre_number = M_2; // 中音re
    32'D55:pre_number = M_2; // 重复中音re
    32'D56:pre_number = M_3; // 中音mi
    32'D57:pre_number = M_3; // 重复中音mi
    32'D58:pre_number = M_4; // 中音fa
    32'D59:pre_number = M_4; // 重复中音fa
    32'D60:pre_number = M_3; // 中音mi
    32'D61:pre_number = M_3; // 重复中音mi
    32'D62:pre_number = M_2; // 中音re
    32'D63:pre_number = M_2; // 重复中音re
    32'D64:pre_number = L_1; // 低音do
    32'D65:pre_number = M_2; // 重复中音re
    32'D66:pre_number = M_3; // 中音mi
    32'D67:pre_number = 0; // 停顿
    32'D68:pre_number = M_3; // 重复中音mi
    32'D69:pre_number = 0; // 停顿
    32'D70:pre_number = M_3; // 重复中音mi
    32'D71:pre_number = 0; // 停顿
    32'D72:pre_number = M_3; // 重复中音mi
    32'D73:pre_number = M_3; // 重复中音mi
    32'D74:pre_number = M_2; // 中音re
    32'D75:pre_number = M_3; // 中音mi
    32'D76:pre_number = M_2; // 中音re
    32'D77:pre_number = M_2; // 重复中音re
    32'D78:pre_number = M_1; // 中音do
    32'D79:pre_number = M_1; // 重复中音do
    32'D80:pre_number = M_1; // 中音do
    32'D81:pre_number = M_1; // 重复中音do
    32'D82:pre_number = L_5; // 中音so
    32'D83:pre_number = L_5; // 中音so
    32'D84:pre_number = M_1; // 中音do
    32'D85:pre_number = M_1; // 中音do
    32'D86:pre_number = M_2; // 中音re
    32'D87:pre_number = M_2; // 重复中音re
    32'D88:pre_number = M_3; // 中音mi
    32'D89:pre_number = M_3; // 重复中音mi
    32'D90:pre_number = M_4; // 中音fa
    32'D91:pre_number = M_4; // 重复中音fa
    32'D92:pre_number = M_3; // 中音mi
    32'D93:pre_number = M_3; // 重复中音mi
    32'D94:pre_number = M_2; // 中音re
    32'D95:pre_number = M_2; // 重复中音re
    32'D96:pre_number = L_1; // 低音do
    32'D97:pre_number = M_2; // 重复中音re
    32'D98:pre_number = M_3; // 中音mi
    32'D99:pre_number = 0; // 停顿
    32'D100:pre_number = M_3; // 重复中音mi
    32'D101:pre_number = 0; // 停顿
    32'D102:pre_number = M_3; // 重复中音mi
    32'D103:pre_number = 0; // 停顿
    32'D104:pre_number = M_3; // 重复中音mi
    32'D105:pre_number = M_3; // 重复中音mi
    32'D106:pre_number = M_2; // 中音re
    32'D107:pre_number = M_3; // 中音mi
    32'D108:pre_number = M_2; // 中音re
    32'D109:pre_number = M_2; // 重复中音re
    32'D110:pre_number = M_1; // 中音do
    32'D111:pre_number = M_1; // 重复中音do
    32'D112:pre_number = M_1; // 中音do
    32'D113:pre_number = M_1; // 重复中音do
    default: pre_number = 32'h0;
   endcase
  end
end
```
- 这个部分用于控制乐谱的播放。它通过状态机 `state` 来选择不同的音符，并通过计数器 `beat_time` 来控制每个音符的持续时长。当 `beat_time` 达到预设的时长 `TIME` 时，状态机 `state` 自动切换到下一个音符，并重置 `beat_time`。

这个模块通过时钟信号 `clk` 控制蜂鸣器的频率和乐谱的播放。当蜂鸣器频率改变时，它会发出不同的音调；当乐谱状态机切换到下一个音符时，它会播放不同的音阶。

#### 管脚分配

本组直接通过编写 `TabletFillingMachine.xdc` 约束文件来完成引脚分配。

以下是 `TabletFillingMachine.xdc` 的引脚和信号分配的表格：

| 信号                | 引脚  | IOSTANDARD |
|---------------------|-------|------------|
| clk                 | P17   | LVCMOS33   |
| reset               | P15   | LVCMOS33   |
| down                | R17   | LVCMOS33   |
| left                | V1    | LVCMOS33   |
| right               | R11   | LVCMOS33   |
| up                  | U4    | LVCMOS33   |
| set                 | N4    | LVCMOS33   |
| fill                | R15   | LVCMOS33   |
| beep                | T1    | LVCMOS33   |
| sd                  | M6    | LVCMOS33   |
| left_duan[0]        | B4    | LVCMOS33   |
| left_duan[1]        | A4    | LVCMOS33   |
| left_duan[2]        | A3    | LVCMOS33   |
| left_duan[3]        | B1    | LVCMOS33   |
| left_duan[4]        | A1    | LVCMOS33   |
| left_duan[5]        | B3    | LVCMOS33   |
| left_duan[6]        | B2    | LVCMOS33   |
| left_duan[7]        | D5    | LVCMOS33   |
| right_duan[0]       | D4    | LVCMOS33   |
| right_duan[1]       | E3    | LVCMOS33   |
| right_duan[2]       | D3    | LVCMOS33   |
| right_duan[3]       | F4    | LVCMOS33   |
| right_duan[4]       | F3    | LVCMOS33   |
| right_duan[5]       | E2    | LVCMOS33   |
| right_duan[6]       | D2    | LVCMOS33   |
| right_duan[7]       | H2    | LVCMOS33   |
| left_wei[0]         | G2    | LVCMOS33   |
| left_wei[1]         | C2    | LVCMOS33   |
| left_wei[2]         | C1    | LVCMOS33   |
| left_wei[3]         | H1    | LVCMOS33   |
| right_wei[0]        | G1    | LVCMOS33   |
| right_wei[1]        | F1    | LVCMOS33   |
| right_wei[2]        | E1    | LVCMOS33   |
| right_wei[3]        | G6    | LVCMOS33   |

### 调试过程中的问题及讨论

- 有时按键抖动（与项目A相同）

  - 问题描述：在按键按下时，有时会出现按键抖动的情况。

  - 问题分析：机械开关接触不良等原因产生的短暂信号跳变。

  - 解决方案：添加去抖动模块 `debounce`。

- 药片增量不正确

  - 问题描述：药片增量不正确。

  - 问题分析：可能是 `TabletFillingMachine` 模块的 `CAPACITY` 出现了问题。

  - 解决方案：将 `TabletFillingMachine` 模块中的第80行改为 `tablet_cnt == CAPACITY-1`

### 设计调试小结

- 设计小结：我们的设计分为多模块，每个模块都实现了特定的功能。通过顶层模块将这些模块组合起来，我们实现了完整的药片填充系统。

- 调试过程中，我们遇到了一些问题，如按键抖动和药片增量不正确。我们通过添加去抖动模块 `debounce` 和修改 `TabletFillingMachine` 模块的第80行解决了这些问题。

- 由于这个是项目中较为简单的一个，我们在调试过程中遇到的困难较少，不过，我们在调试中也学到了一些东西，促成我们的成长。

## 自主拓展：贪吃蛇

### 题目分析

- 实现一个简单的贪吃蛇游戏，玩家可以通过方向按钮来控制贪吃蛇的方向，通过吃食物来增加分数。
- 当贪吃蛇撞到墙壁或自己时，游戏结束，显示游戏结束标志。

### 设计详解

#### 顶层模块 `module snake` 

##### I. 顶层模块 `module snake` 的输入输出

```verilog
module snake (
  input clk,
  input reset,
  input left,  // 按钮输入
  input right,
  input up,
  input down,
  output [3:0] red,
  output [3:0] green,
  output [3:0] blue,
  output hsync,
  output vsync,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan,
  inout ps2_clk,
  inout ps2_data
);
```
1. **输入信号**:
   - `clk`: 时钟信号，用于同步模块内的操作。
   - `reset`: 异步复位信号，高电平时重置整个系统。
   - `left`, `right`, `up`, `down`: 方向按钮输入，用于控制贪吃蛇的方向。
   - `ps2_clk`, `ps2_data`: PS/2键盘输入，用于接收键盘输入。
2. **输出信号**:
   - `red`, `green`, `blue`: VGA信号输出，用于驱动显示器。
   - `hsync`, `vsync`: VGA信号输出，用于同步显示器。
   - `left_wei`, `left_duan`, `right_wei`, `right_duan`: 数码管输出，用于显示分数和游戏结束标志。

##### II. 内部信号
```verilog
wire [11:0]color;
wire [9:0]x,y;  // 640x480
wire valid;
wire [7:0] ascii_code;
wire right_p,left_p,up_p,down_p;
wire [15:0] score;
wire game_over;
```
   - `color`: 12位的颜色信号，用于VGA显示。
   - `x`, `y`: 坐标信号，用于VGA显示。
   - `valid`: 信号，用于指示键盘输入的有效性。
   - `ascii_code`: 8位的ASCII码信号，用于表示键盘输入的字符。
   - `right_p`, `left_p`, `up_p`, `down_p`: 信号，用于指示方向按钮的按下状态。
   - `score`: 16位的计数器，用于显示游戏分数。
   - `game_over`: 信号，用于指示游戏是否结束。

##### III. 去抖动
```verilog 
wire left_clean, right_clean, up_clean, down_clean;
debounce db_left(
  .clk(clk),
  .reset(reset),
  .noisy_signal(left),
  .clean_signal(left_clean)
);
debounce db_right(
  .clk(clk),
  .reset(reset),
  .noisy_signal(right),
  .clean_signal(right_clean)
);
debounce db_up(
  .clk(clk),
  .reset(reset),
  .noisy_signal(up),
  .clean_signal(up_clean)
);
debounce db_down(
  .clk(clk),
  .reset(reset),
  .noisy_signal(down),
  .clean_signal(down_clean)
);
```
   - `left_clean`, `right_clean`, `up_clean`, `down_clean`是去抖动后的信号。
   - `debounce`模块用于去除按钮输入的抖动，确保按钮状态的稳定。
   - 每个按钮输入都有一个独立的`debounce`实例，它们都接收相同的`clk`和`reset`信号，以及各自的噪声信号和清洁信号。

##### IV. VGA
```verilog
vga vga_shower(
  .clk(clk),
  .new_data(color),
  .red(red),
  .green(green),
  .blue(blue),
  .hsync(hsync),
  .vsync(vsync),
  .pos_x(x),
  .pos_y(y)
);
```
   - `VGA`显示模块：负责显示游戏画面。

##### V. 键盘处理
```verilog
wire valid;
wire [7:0] ascii_code;
ps2 ps(clk, reset,ps2_clk,ps2_data,valid,ascii_code);
wire right_p,left_p,up_p,down_p;
assign right_p = right_clean || ascii_code == 8'h44;
assign left_p = left_clean || ascii_code == 8'h41;
assign up_p = up_clean || ascii_code == 8'h57;
assign down_p = down_clean || ascii_code == 8'h53;
```
- `wire valid;`：声明一个有效信号 `valid`，用于表示 PS/2 键盘输入的有效性。
- `wire [7:0] ascii_code;`：声明一个 8 位的信号 `ascii_code`，用于存储接收到的 PS/2 键盘传来的 ASCII 码值。
- `ps2 ps(clk, reset, ps2_clk, ps2_data, valid, ascii_code);`：实例化一个 PS/2 模块 `ps`，该模块用于接收 PS/2 键盘输入信号，并将有效信号和 ASCII 码值传递给 `valid` 和 `ascii_code`。
- `wire right_p, left_p, up_p, down_p;`：声明四个逻辑信号 `right_p`、`left_p`、`up_p`、`down_p`，用于表示贪吃蛇游戏中的四个方向控制。
- `assign right_p = right_clean || ascii_code == 8'h44;`：如果右方向键 `right` 被按下或者接收到键盘发送的ASCII码为 `8'h44`（即键盘上的特定按键对应的 ASCII 码），则 `right_p` 信号为高，表示向右移动。
- `assign left_p = left_clean || ascii_code == 8'h41;`：类似地，映射左移动。
- `assign up_p = up_clean || ascii_code == 8'h57;`：映射上移动。
- `assign down_p = down_clean || ascii_code == 8'h53;`：映射下移动。

##### VI. 贪吃蛇主体

```verilog
wire [15:0] score;
wire game_over;
snake_model snaker(
  .clk(clk),.reset(reset),
  .left(left_p),.right(right_p),.up(up_p),.down(down_p),
  .pix_x(x),.pix_y(y),
  .color(color),.score(score),.game_over(game_over)
);
```
   - 根据按钮输入和VGA坐标来控制贪吃蛇的行为

##### VI. 显示
```verilog
score_show score_shower(
  .clk(clk),
  .lcnt(0),
  .rcnt(score),
  .game_over(game_over),
  .left_wei(left_wei),  // 左边的数码管
  .left_duan(left_duan),  //
  .right_wei(right_wei),  //
  .right_duan(right_duan)
);
```
   - 接收游戏分数和游戏结束标志，并根据这些信息来控制数码管的显示。


#### 去抖动模块 `module debounce`

1. **模块定义**：
```verilog
module debounce(
  input clk,  // 100MHz
  input reset,
  input noisy_signal,
  output reg clean_signal
);
   ```
- 定义一个名为`debounce`的模块，它有四个端口：一个时钟输入`clk`（频率为100MHz），一个复位输入`reset`，一个噪声信号输入`noisy_signal`，以及一个输出信号`clean_signal`，这个输出信号将是经过消抖处理的信号。
2. **内部寄存器**：
```verilog
reg [20:0] counter;
reg stable_signal;
```
- 这里定义了两个寄存器：`counter`用于计数，宽度为21位`stable_signal`用于存储当前的稳定信号状态。
3. **时序逻辑**：
```verilog
always @(posedge clk, posedge reset) begin
  if (reset) begin
    counter <= 0;
    clean_signal <= 0;
    stable_signal <= 0;
  end else begin
    // ...
  end
end
```
- 这个`always`块是一个时序逻辑块，它在时钟的上升沿或复位信号的下降沿触发。如果复位信号被激活（高电平有效），则计数器、干净信号和稳定信号都被清零。否则，执行以下逻辑。
4. **消抖逻辑**：
```verilog
if (noisy_signal == stable_signal) begin
  // 当输入信号与当前稳定信号相同时，增加计数器
  if (counter < 2000000)  // 等待大约20ms
    counter <= counter + 1;
  else
    clean_signal <= stable_signal;  // 更新输出信号
end else begin
  // 如果输入信号改变，重置计数器并更新稳定信号
  counter <= 0;
  stable_signal <= noisy_signal;
end
```
- 这部分是消抖逻辑的核心。如果噪声信号`noisy_signal`与当前的稳定信号`stable_signal`相同，计数器开始计数。当计数器达到2000000（大约对应于20ms，因为时钟频率为100MHz），则认为信号稳定，并将`clean_signal`更新为`stable_signal`。如果`noisy_signal`与`stable_signal`不同，则计数器被重置，`stable_signal`被更新为新的`noisy_signal`。

此模块通过计数机制实现了消抖功能。当输入信号在一段时间内保持不变时，它才更新输出信号。这样可以过滤掉由于机械开关接触不良等原因产生的短暂信号跳变，确保输出信号的稳定性。

#### VGA 模块 `module vga`

1. **模块定义**
```verilog
module vga(
  input clk,          // 100MHz 时钟输入
  input [11:0]new_data,  // 下一个(r,g,b)
  output [3:0] red,   // 4位红色信号
  output [3:0] green, // 4位绿色信号
  output [3:0] blue,  // 4位蓝色信号
  output hsync,       // 水平同步信号
  output vsync,        // 垂直同步信号
  output [9:0] pos_x,  // 当前横坐标
  output [9:0] pos_y
);
```
- 定义一个名为`vga`的模块。
- `clk`：100MHz 时钟输入信号。
- `new_data`：由外部提供的 RGB 数据，12 位宽，共有红色、绿色和蓝色三部分信号，每部分信号 4 位。
- `red`、`green`、`blue`：VGA 显示的红、绿、蓝三原色信号，输出端口，每个信号 4 位。
- `hsync`：水平同步信号，输出端口，用于指示屏幕的行扫描。
- `vsync`：垂直同步信号，输出端口，用于指示屏幕的帧扫描。
- `pos_x`、`pos_y`：当前像素的横坐标和纵坐标，输出端口，用于定位当前像素位置。

2. **内部寄存器和信号**
```verilog
reg [9:0] hcount; //VGA 行扫描计数器
reg [9:0] vcount; //VGA 场扫描计数器
wire [11:0] data;  // (r,g,b)
reg [1:0]cnt;
wire hcount_ov;
wire vcount_ov;
wire dat_act;
reg vga_clk;
```
- `hcount`：用于表示当前行扫描的位置（像素计数）。
- `vcount`：用于表示当前场扫描的位置（行计数）。
- `data`：用于存储当前需要显示的RGB数据。
- `cnt`：2 位计数器，用于生成 VGA 时钟（25MHz）。
- `hcount_ov`：水平计数器溢出信号。
- `vcount_ov`：垂直计数器溢出信号。
- `dat_act`：激活显示数据的标志信号。
- `vga_clk`：VGA 时钟信号。

3. **参数定义**
```verilog
parameter
  hsync_end = 10'd95,
  hdat_begin = 10'd143,
  hdat_end = 10'd783,
  hpixel_end = 10'd799,
  vsync_end = 10'd1,
  vdat_begin = 10'd34,
  vdat_end = 10'd514,
  vline_end = 10'd524;
```
定义了一些 VGA 时序相关的参数，主要规定了水平和垂直同步信号的周期，以及有效显示区域的范围。
- `hsync_end`：水平同步结束的像素位置，即HSYNC信号的宽度为95个像素。
- `hdat_begin`：水平显示数据开始的像素位置，HSYNC结束后还有一段背景色区域，到第143个像素位置开始显示数据。
- `hdat_end`：水平显示数据结束的像素位置，第783个像素位置数据显示结束。
- `hpixel_end`：水平一行的结束像素位置，总宽度为800个像素（0到799）。
- `vsync_end`：垂直同步结束的行位置，即VSYNC信号的高度为1行。
- `vdat_begin`：垂直显示数据开始的行位置，在一些前置的非显示行后，从第34行开始显示数据。
- `vdat_end`：垂直显示数据结束的行位置，第514行数据显示结束。
- `vline_end`：垂直一帧的结束行位置，总高度为525行（0到524）。

4. **时钟分频**

```verilog
always @(posedge clk) begin
  if(cnt==3)
    cnt <= 0;
  else
    cnt <= cnt + 1;
end
always @(posedge clk) begin
  if(cnt < 2)
    vga_clk <= 1;
  else
    vga_clk <= 0;
end
```
这部分代码使用一个 2 位计数器对输入时钟 `clk` 进行分频，从 100MHz 降至 25MHz，得到 `vga_clk`。

5. **行扫描和场扫描**

- 行扫描
```verilog
always @(posedge vga_clk) begin
  if (hcount_ov)
    hcount <= 10'd0;
  else
    hcount <= hcount + 10'd1;
end
assign hcount_ov = (hcount == hpixel_end);
```
在每个 VGA 时钟周期内，`hcount` 递增，当 `hcount` 达到`hpixel_end`（799）时溢出，重置为 0。

- 场扫描
```verilog
always @(posedge vga_clk) begin
  if (hcount_ov) begin
    if (vcount_ov)
      vcount <= 10'd0;
    else
      vcount <= vcount + 10'd1;
  end
end
assign vcount_ov = (vcount == vline_end);
```
在每行扫描结束时 (`hcount_ov` 为真)，`vcount` 递增，当 `vcount` 达到`vline_end`（524）时溢出，重置为 0。

6. **数据和同步信号输出**

```verilog
assign dat_act = ((hcount >= hdat_begin) && (hcount < hdat_end)) && ((vcount >= vdat_begin) && (vcount < vdat_end));
assign hsync = (hcount > hsync_end);
assign vsync = (vcount > vsync_end);
assign red = (dat_act) ? data[11:8] : 3'h00;
assign green = (dat_act) ? data[7:4] : 3'h00;
assign blue = (dat_act) ? data[3:0] : 3'h00;
```
- `dat_act` 用于判断当前时刻是否在有效显示区域内，只有在有效显示区内，`dat_act` 才为真。
- `hsync` 和 `vsync` 分别在它们的同步区间之外为真，表示显示器可以进行下一步行或帧的显示。
- `red`、`green` 和 `blue` 信号只有在有效显示区间内（`dat_act` 为真）才会被赋值为 `data` 的对应颜色分量，否则为 0。

7. **显示数据处理**
```verilog
assign pos_x = hcount-hdat_begin;
assign pos_y = vcount-vdat_begin;
assign data = new_data;
```
- `pos_x` 和 `pos_y` 分别表示当前像素在有效显示区域内的坐标。
- `data` 直接赋值为外部输入的 `new_data`。

#### PS2 模块 `module ps2`

1. **模块定义**
```verilog
module ps2(clk, reset,ps2k_clk,ps2k_data,ps2_state,ps2_asci);
input clk;    //时钟信号
input reset;  //复位信号
input ps2k_clk;  //PS2接口时钟信号
input ps2k_data;    //PS2接口数据信号
output ps2_state;    //键盘当前状态，ps2_state=1表示有键被按下
output reg[7:0] ps2_asci;  //接收数据的相应ASCII码
```
- `input clk`：输入时钟信号。
- `input reset`：输入复位信号。
- `input ps2k_clk`：PS/2键盘时钟信号。
- `input ps2k_data`：PS/2键盘数据信号。
- `output ps2_state`：键盘当前状态，表示是否有键被按下。
- `output reg [7:0] ps2_asci`：接收的数据的相应ASCII码。

2. **内部信号和寄存器**
```verilog
reg ps2k_clk_r0,ps2k_clk_r1,ps2k_clk_r2;  //ps2k_clk状态寄存器
wire neg_ps2k_clk;  // ps2k_clk下降沿标志位
reg[7:0] ps2_byte_r;    //PC接收来自PS2的一个字节数据存储器
reg[7:0] temp_data;      //当前接收数据寄存器
reg[3:0] num;        //计数寄存器
```
- `ps2k_clk_r0`、`ps2k_clk_r1`、`ps2k_clk_r2`：用于滤波的PS/2时钟信号寄存器。
- `neg_ps2k_clk`：PS/2时钟的下降沿标志。
- `ps2_byte_r`：存储当前接收的一个字节数据。
- `temp_data`：当前接收数据的寄存器。
- `num`：用于计数数据位的计数器。

3. **滤波和边沿检测**

- 滤波
```verilog
always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    ps2k_clk_r0 <= 1'b0;
    ps2k_clk_r1 <= 1'b0;
    ps2k_clk_r2 <= 1'b0;
  end else begin
    ps2k_clk_r0 <= ps2k_clk;
    ps2k_clk_r1 <= ps2k_clk_r0;
    ps2k_clk_r2 <= ps2k_clk_r1;
  end
end
```
用于对PS/2时钟信号进行滤波，以消除抖动。

- 检测下降沿
```verilog
assign neg_ps2k_clk = ~ps2k_clk_r1 & ps2k_clk_r2;
```
检测PS/2时钟信号的下降沿，当检测到下降沿时，`neg_ps2k_clk`为高。

4. **数据采集**

```verilog
always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    num <= 4'd0;
    temp_data <= 8'd0;
  end else if(neg_ps2k_clk) begin
    case (num)
      4'd0: num <= num + 1'b1;
      4'd1: begin
        num <= num + 1'b1;
        temp_data[0] <= ps2k_data;  // bit0
      end
      4'd2: begin
        num <= num + 1'b1;
        temp_data[1] <= ps2k_data;  // bit1
      end
      4'd3: begin
        num <= num + 1'b1;
        temp_data[2] <= ps2k_data;  // bit2
      end
      4'd4: begin
        num <= num + 1'b1;
        temp_data[3] <= ps2k_data;  // bit3
      end
      4'd5: begin
        num <= num + 1'b1;
        temp_data[4] <= ps2k_data;  // bit4
      end
      4'd6: begin
        num <= num + 1'b1;
        temp_data[5] <= ps2k_data;  // bit5
      end
      4'd7: begin
        num <= num + 1'b1;
        temp_data[6] <= ps2k_data;  // bit6
      end
      4'd8: begin
        num <= num + 1'b1;
        temp_data[7] <= ps2k_data;  // bit7
      end
      4'd9: begin
        num <= num + 1'b1;  // 奇偶校验位，不做处理
      end
      4'd10: begin
        num <= 4'd0;  // num清零
      end
      default: ;
    endcase
  end
end
```
- 在每个PS/2时钟信号的下降沿采集数据位，将数据位依次存入`temp_data`，采集完成后计数器`num`清零。

5. **数据处理**

- 松键标志和键盘状态
```verilog
reg key_f0;  // 松键标志位
reg ps2_state_r;  // 键盘当前状态

always @ (posedge clk or negedge reset) begin
  if(!reset) begin
    key_f0 <= 1'b0;
    ps2_state_r <= 1'b0;
  end else if(num == 4'd10) begin  // 一帧数据是否采集完
    if(temp_data == 8'hf0) key_f0 <= 1'b1;  // 判断是否为断码
    else begin
      if(!key_f0) begin
        ps2_state_r <= 1'b1;  // 有键按下
        ps2_byte_r <= temp_data;  // 锁存当前键值
      end else begin
        ps2_state_r <= 1'b0;
        key_f0 <= 1'b0;
      end
    end
  end
end
assign ps2_state = ps2_state_r;
```
检测到`f0`码时，松键标志置1，否则判断是否为按键事件，并根据键值更新键盘状态。

6. **ASCII码转换**
```verilog
always @ (ps2_byte_r) begin
  case (ps2_byte_r)
    8'h15: ps2_asci <= 8'h51;  // Q
    8'h1d: ps2_asci <= 8'h57;  // W
    8'h24: ps2_asci <= 8'h45;  // E
    8'h2d: ps2_asci <= 8'h52;  // R
    8'h2c: ps2_asci <= 8'h54;  // T
    8'h35: ps2_asci <= 8'h59;  // Y
    8'h3c: ps2_asci <= 8'h55;  // U
    8'h43: ps2_asci <= 8'h49;  // I
    8'h44: ps2_asci <= 8'h4f;  // O
    8'h4d: ps2_asci <= 8'h50;  // P
    8'h1c: ps2_asci <= 8'h41;  // A
    8'h1b: ps2_asci <= 8'h53;  // S
    8'h23: ps2_asci <= 8'h44;  // D
    8'h2b: ps2_asci <= 8'h46;  // F
    8'h34: ps2_asci <= 8'h47;  // G
    8'h33: ps2_asci <= 8'h48;  // H
    8'h3b: ps2_asci <= 8'h4a;  // J
    8'h42: ps2_asci <= 8'h4b;  // K
    8'h4b: ps2_asci <= 8'h4c;  // L
    8'h1a: ps2_asci <= 8'h5a;  // Z
    8'h22: ps2_asci <= 8'h58;  // X
    8'h21: ps2_asci <= 8'h43;  // C
    8'h2a: ps2_asci <= 8'h56;  // V
    8'h32: ps2_asci <= 8'h42;  // B
    8'h31: ps2_asci <= 8'h4e;  // N
    8'h3a: ps2_asci <= 8'h4d;  // M
    default: ;
  endcase
end
```
- 根据接收到的扫描码，将其转换为相应的ASCII码。ASCII码的映射主要针对字母键。

#### 贪吃蛇主体模块 `module snake_model`

1. **模块定义**
```verilog
module snake_model(
  clk,reset,left,right,up,down,pix_x,pix_y,
  color,score,game_over
);

input clk;
input reset;
input left;
input right;
input up;
input down;

input signed [15:0] pix_x;
input signed [15:0] pix_y;

output reg [11:0] color;
output wire [15:0] score;
output reg game_over = 1;
```
- `clk` 时钟信号。
- `reset` 复位信号。
- `left`、`right`、`up`、`down` 用于控制蛇移动的方向。
- `pix_x` 和 `pix_y` 是像素坐标。
- `color` 用于输出当前像素的颜色。
- `score` 用于输出当前得分。
- `game_over` 用于指示游戏是否结束。

2. **参数定义**
```verilog
parameter speed = 5,
  width = 640,
  height = 480,
  MAX_LEN = 18,
  RAD = 10,
  FLASH_CLOCK = 10000000;  // 游戏刷新周期（100MHZ/FLASH_CLOCK）
```
- `speed` 定义蛇的移动速度。
- `width` 和 `height` 定义屏幕的宽度和高度。
- `MAX_LEN` 定义蛇的最大长度。
- `RAD` 定义蛇节点的半径。
- `FLASH_CLOCK` 用来设置游戏刷新周期。

3. **内部信号和寄存器**
```verilog
reg signed [15:0] dir[1:0];
reg signed [15:0] food_x_temp;
reg signed [15:0] food_y_temp;
wire signed [15:0] food_x, food_y;
reg signed [15:0] snake_pos[MAX_LEN:0][1:0];
reg [15:0] snake_len = 1;
reg clk_game = 0;
reg [32:0] clk_counter;
```
- `dir` 用于存储蛇的移动方向。
- `food_x` 和 `food_y` 用于存储食物的位置。
- `snake_pos` 用于存储蛇的每个节点的位置。
- `snake_len` 用于存储蛇的当前长度。
- `clk_game` 是游戏时钟。
- `clk_counter` 是时钟分频计数器。

4. **时钟分频**
```verilog
always @(posedge clk) begin
  if (clk_counter == FLASH_CLOCK / 2 - 1) begin
    clk_counter <= 0;
    clk_game <= ~clk_game;
  end else begin
    clk_counter <= clk_counter + 1;
  end
end
```
用于将输入时钟信号分频，得到游戏时钟信号。

5. **方向控制**
```verilog
always @(posedge clk or negedge reset) begin
  if (~reset) begin
    dir[0] <= 0;
    dir[1] <= 1;
  end else begin
    if (left || right || up || down) begin
      if (left && dir[0] != 1 && dir[1] != 0) begin
        dir[0] <= -1;
      end else if (right && dir[0] != -1 && dir[1] != 0) begin
        dir[0] <= 1;
      end else begin
        dir[0] <= 0;
      end
      if (up && dir[0] != 0 && dir[1] != 1) begin
        dir[1] <= -1;
      end else if (down && dir[0] != 0 && dir[1] != -1) begin
        dir[1] <= 1;
      end else begin
        dir[1] <= 0;
      end
    end
  end
end
```
根据输入方向信号生成蛇的移动方向，避免蛇的逆向移动（即避免180度转向）。

6. **食物位置生成与蛇的移动**
```verilog
always @(posedge clk, negedge reset) begin: move
  integer k;
  if (!reset) begin
    snake_cnt <= 0;
    for (k = 0; k < MAX_LEN; k = k + 1) begin
      snake_pos[k][0] <= width / 2;
      snake_pos[k][1] <= height / 2;
    end
   end else if(!game_over) begin
    if (snake_cnt == FLASH_CLOCK) begin  // 每隔10 ms 移动一次
      snake_cnt = 0;
      for (k=MAX_LEN-2; k >= 0; k = k-1) begin
        snake_pos[k+1][0] = snake_pos[k][0];
        snake_pos[k+1][1] = snake_pos[k][1];
      end
      snake_pos[0][0] = (snake_pos[0][0] + speed*dir[0] + width) % width;
      snake_pos[0][1] = (snake_pos[0][1] + speed*dir[1] + height) % height;
    end else begin
      snake_cnt = snake_cnt + 1;
    end
  end
end
```
蛇的移动逻辑：蛇头的移动方向由`dir`决定，其他部分紧随蛇头移动。

7. **食物的生成和吃食物处理**
```verilog
always @(posedge clk_game, negedge reset) begin: eat
  integer k;
  if (!reset) begin
    food_x_temp <= 100 + (rand % 300);
    food_y_temp <= 100 + (next_rand(rand) % 300);
    snake_len <= 1;
  end else if (in_circle(snake_pos[0][0], snake_pos[0][1], food_x, food_y)) begin
    food_x_temp <= (rand % width);
    food_y_temp <= (next_rand(rand) % height);
    if (snake_len < MAX_LEN) begin
      snake_len <= snake_len + 1;
    end
  end
end
```
当蛇头与食物重合时，产生新的食物位置并增加蛇的长度。

8. **游戏结束检测**
```verilog
always @(posedge clk_game, negedge reset) begin: game_over_block
  integer k;
  if (!reset) begin
    game_over <= 0;
  end else if (in_snake_body(snake_pos[0][0], snake_pos[0][1])) begin
    game_over <= 1;
  end
end
```
当蛇头与蛇身其他部分重合时，游戏结束。

9. **显示逻辑**
```verilog
always @(posedge clk) begin
  if (food_x < 0 || food_y < 0 || food_x > width || food_y > height) begin
    color <= 12'h0f0;
  end else if (game_over) begin
    color <= pix_x + pix_y;
  end else if (in_snake(pix_x, pix_y)) begin
    color <= 12'h0ff;
  end else if (in_circle(pix_x, pix_y, food_x, food_y)) begin
    color <= 12'hf00;
  end else begin
    color <= 12'hfff;
  end
end
```
根据蛇的位置、食物的位置、游戏状态和像素坐标，决定要显示的颜色。

#### 得分显示模块 `module score_show`

1. **模块定义**：
```verilog
module score_show(
  input clk,
  input [15:0]lcnt,
  input [15:0]rcnt,
  input game_over,
  output [3:0] left_wei,  // 左边的数码管
  output [7:0] left_duan,  //
  output [3:0] right_wei,  //
  output [7:0] right_duan
);
```
- `module score_show` 定义了一个分数显示模块，它有多个输入和输出。输入包括时钟信号`clk`、左边的分数`lcnt`和右边的分数`rcnt`，以及游戏结束信号`game_over`。输出包括左边的数码管的位选信号`left_wei`、段选信号`left_duan`，以及右边的数码管的位选信号`right_wei`和段选信号`right_duan`。

2. **分频器**：
```verilog
reg clk_2Hz = 0;  // 1HZ
  reg [32:0] counter_2Hz=0;
  always @(posedge clk) begin
    if (counter_2Hz == 50000000/2-1) begin
      counter_2Hz<=0;
      clk_2Hz<=~clk_2Hz;
    end else counter_2Hz <= counter_2Hz+1;
  end
```
- 使用`counter_2Hz`寄存器和一个始终沿触发的always块来生成一个2Hz的时钟信号`clk_2Hz`。这是通过在100MHz时钟信号的基础上进行分频来实现的。

3. **闪烁控制**：
```verilog
reg[7:0] flash = 0;
  always @(posedge clk_2Hz) begin
    if (game_over) begin
      flash <= ~flash;
    end else begin
      flash <= ~(8'd0);
    end
  end
  assign left_duan = (flash & sm_left_duan) ;
  assign right_duan = (flash & sm_right_duan) ;
```
- 使用`flash`寄存器和一个始终沿触发的always块来控制数码管的闪烁。当游戏结束时，数码管开始闪烁。

4. **获取段选信号和位选信号**：
```verilog
assign lcnt_thousands  = (lcnt / 1000) % 10;
assign lcnt_hundreds  = (lcnt / 100) % 10;
assign lcnt_tens      = (lcnt / 10) % 10;
assign lcnt_units     = lcnt % 10;

assign rcnt_thousands  = (rcnt / 1000) % 10;
assign rcnt_hundreds  = (rcnt / 100) % 10;
assign rcnt_tens      = (rcnt / 10) % 10;
assign rcnt_units     = rcnt % 10;
always @(posedge clk) begin
  left_data <= {
    lcnt_units,lcnt_tens,
    lcnt_hundreds,lcnt_thousands
  };
  right_data <= {
    rcnt_units,rcnt_tens,
    rcnt_hundreds,rcnt_thousands
  };
end
```
- 使用逻辑运算，根据`lcnt`和`rcnt`的值，分别计算左边的数码管和右边的数码管的段选信号和位选信号。

5. **数字显示模块实例化**：
```verilog
smg_ip_model smg_left(
    .clk(clk), .data(left_data),
    .sm_wei(left_wei), .sm_duan(sm_left_duan)  // 位选信号不用处理，直接输出即可
  );
  smg_ip_model smg_right(
    .clk(clk), .data(right_data),
    .sm_wei(right_wei), .sm_duan(sm_right_duan)
  );
```
- 使用 `smg_ip_model` 模块来处理数字显示。这个模块是一个IP核，用于将数字数据转换为数码管的位选信号和段选信号。

- 在`score_show`模块中，实例化了两个`smg_ip_model`模块，一个用于左边数码管的显示，另一个用于右边数码管的显示。

总的来说，这个模块实现了一个分数显示功能，可以显示左边的分数`lcnt`和右边的分数`rcnt`。当游戏结束时，数码管开始闪烁。

#### 数码管显示模块 `module smg_ip_model`
1. **模块定义**：
```verilog
module smg_ip_model(clk,data,sm_wei,sm_duan);
```
- 定义了名为 `smg_ip_model` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`data` 是输入的数据信号，`sm_wei` 是位选信号，`sm_duan` 是段选信号。
2. **分频逻辑**：
```verilog
integer clk_cnt=0;
reg clk_1kHz=0;
always @(posedge clk) begin
  if(clk_cnt==32'd50000-1)
    begin clk_cnt <= 1'b0; clk_1kHz <= ~clk_1kHz;end
  else begin
    clk_cnt <= clk_cnt + 1'b1;
  end
end
```
- 这个部分用于将输入的时钟信号 `clk` 分频为 1kHz 的时钟信号 `clk_1kHz`。
3. **位控制逻辑**：
```verilog
reg [3:0]wei_ctrl=4'b1110;
always @(posedge clk_1kHz) begin
  wei_ctrl <= {wei_ctrl[2:0],wei_ctrl[3]};  // 循环移位
end
```
- 这个部分用于控制位选信号 `sm_wei`。它将 `wei_ctrl` 寄存器的值进行循环移位，以产生不同的位选信号。
4. **段控制逻辑**：
```verilog
reg [3:0]duan_ctrl;
always @(posedge clk) begin
  case(wei_ctrl)
    // ...
  default : duan_ctrl=4'hf;
  endcase
end
```
- 这个部分用于控制段选信号 `sm_duan`。它根据位选信号 `wei_ctrl` 的值，选择相应的段选信号 `duan_ctrl`，并将它输出到 `sm_duan`。
5. **解码模块**：
```verilog
reg [7:0]duan;
always @(posedge clk) begin
  case(duan_ctrl)
    // ...
  default : duan = 8'b0000_0000;//none
  endcase
end
```
- 这个部分用于解码段选信号 `duan_ctrl`，并输出相应的段选信号 `duan`。
6. **输出信号**：
```verilog
assign sm_wei =~wei_ctrl;
assign sm_duan = duan;
```
- 这两个部分分别将位选信号 `wei_ctrl` 和段选信号 `duan` 输出到 `sm_wei` 和 `sm_duan`。

这个模块通过处理时钟信号、输入的数据信号和位选信号，来输出相应的段选信号，从而控制数码管显示不同的数字或符号。

#### 音频播放模块 `module audio_player`

1. **模块定义**：
```verilog
module audio_player(
  input clk,
  output beep, // 蜂鸣器输出
  output sd
);
```
- 定义名为 `audio_player` 的模块，它包含了指定的输入和输出信号。`clk` 是时钟信号，`beep` 是蜂鸣器控制信号，`sd` 是 SD卡控制信号。
2. **内部寄存器**：
```verilog
reg beep_r;
reg[7:0] state;  // 乐谱状态机
reg[16:0] count, pre_number;
reg[25:0] beat_time;
```
- 这些寄存器用于存储和控制音频播放的状态和计数。
3. **输出信号**：
```verilog
assign sd = 1'b1;
```
- 这个部分将 SD 卡控制信号 `sd` 固定为高电平。
4. **参数定义**：
```verilog
parameter L_1 = 18'd127552,  // 低音1
  L_2 = 18'd113636,  // 低音2
  L_3 = 18'd101236,  // 低音3
  L_4 = 18'd95548,  // 低音4
  L_5 = 18'd85136,  // 低音5
  L_6 = 18'd75838,  // 低音6
  L_7 = 18'd67567,  // 低音7
  M_1 = 18'd63776,  // 中音1
  M_2 = 18'd56818,  // 中音2
  M_3 = 18'd50607,  // 中音3
  M_4 = 18'd47778,  // 中音4
  M_5 = 18'd42553,  // 中音5
  M_6 = 18'd37936,  // 中音6
  M_7 = 18'd33783;  // 中音7
parameter TIME = 50000000; // 每种音阶持续时长为500ms
```
- 这些参数定义了乐谱中不同音符的频率和持续时长。
5. **蜂鸣器控制逻辑**：
```verilog
assign beep = beep_r;
```
- 这个部分将蜂鸣器控制信号 `beep` 设置为 `beep_r` 的值。
6. **计数器逻辑**：
```verilog
always @(posedge clk) begin
  count <= count + 1'b1;
  if(count == pre_number) begin
    count <= 17'h0;
    beep_r <= !beep_r;  // 实际上每个周期分别包括等时长的高电位和低电位，一高一低反复循环，形成不同频率的声音
  end
end
```
- 这个部分用于控制蜂鸣器的频率。它通过计数器 `count` 来控制蜂鸣器的高低电平持续时间。
7. **乐谱状态机逻辑**：
```verilog
always @(posedge clk) begin
  if(beat_time < TIME)
    beat_time = beat_time + 1'b1;
  else begin
    beat_time = 26'd0;
    if(state == 8'd13)
      state = 8'd0;
    else
      state = state + 1'b1;
  case(state)
    32'D0:pre_number = 0;
    32'D1:pre_number = 0;
    32'D2:pre_number = M_5;
    32'D3:pre_number = 0;
    32'D4:pre_number = M_5;
    32'D5:pre_number = M_5;
    32'D6:pre_number = M_1;
    32'D7:pre_number = 0;
    32'D8:pre_number = M_1;
    32'D9:pre_number = M_1;
    32'D10:pre_number = M_1;
    32'D11:pre_number = M_1;
    32'D12:pre_number = M_2; // 重复一次re
    32'D13:pre_number = M_2; // 重复一次re
    32'D14:pre_number = M_3; // 重复一次mi
    32'D15:pre_number = M_3; // 重复一次mi
    // Continue from previous numbering
    32'D16:pre_number = 0;
    32'D17:pre_number = 0; // 重复两次停顿
    32'D18:pre_number = M_5;
    32'D19:pre_number = 0;
    32'D20:pre_number = M_5;
    32'D21:pre_number = M_5;
    32'D22:pre_number = M_1;
    32'D23:pre_number = 0;
    32'D24:pre_number = M_1;
    32'D25:pre_number = M_1;
    32'D26:pre_number = M_2; // 重复一次re
    32'D27:pre_number = M_3; // 重复一次mi
    32'D28:pre_number = M_2; // 重复一次re
    32'D29:pre_number = M_1; // 重复一次do
    32'D30:pre_number = L_5; // 重复一次so
    32'D31:pre_number = L_5; // 重复一次so
    // Assume prior commands reached 32'D31, continue from 32'D32
    32'D32:pre_number = 0; // 停顿
    32'D33:pre_number = 0; // 重复停顿
    32'D34:pre_number = M_5; // 中音so
    32'D35:pre_number = M_5; // 重复中音so
    32'D36:pre_number = M_1; // 中音do
    32'D37:pre_number = M_1; // 重复中音do
    32'D38:pre_number = M_1; // 中音do
    32'D39:pre_number = M_1; // 重复中音do
    32'D40:pre_number = M_2; // 中音re
    32'D41:pre_number = M_2; // 重复中音re
    32'D42:pre_number = M_3; // 中音mi
    32'D43:pre_number = M_3; // 重复中音mi
    // Additional commands to follow sequence
    32'D44:pre_number = M_3; // 中音mi
    32'D45:pre_number = M_3; // 重复中音mi
    32'D46:pre_number = M_2; // 中音re
    32'D47:pre_number = M_2; // 重复中音re
    32'D48:pre_number = M_1; // 中音do
    32'D49:pre_number = M_1; // 重复中音do
    32'D50:pre_number = L_5; // 中音so
    32'D51:pre_number = L_5; // 重复中音so
    32'D52:pre_number = M_1; // 中音do
    32'D53:pre_number = M_1; // 重复中音do
    32'D54:pre_number = M_2; // 中音re
    32'D55:pre_number = M_2; // 重复中音re
    32'D56:pre_number = M_3; // 中音mi
    32'D57:pre_number = M_3; // 重复中音mi
    32'D58:pre_number = M_4; // 中音fa
    32'D59:pre_number = M_4; // 重复中音fa
    32'D60:pre_number = M_3; // 中音mi
    32'D61:pre_number = M_3; // 重复中音mi
    32'D62:pre_number = M_2; // 中音re
    32'D63:pre_number = M_2; // 重复中音re
    32'D64:pre_number = L_1; // 低音do
    32'D65:pre_number = M_2; // 重复中音re
    32'D66:pre_number = M_3; // 中音mi
    32'D67:pre_number = 0; // 停顿
    32'D68:pre_number = M_3; // 重复中音mi
    32'D69:pre_number = 0; // 停顿
    32'D70:pre_number = M_3; // 重复中音mi
    32'D71:pre_number = 0; // 停顿
    32'D72:pre_number = M_3; // 重复中音mi
    32'D73:pre_number = M_3; // 重复中音mi
    32'D74:pre_number = M_2; // 中音re
    32'D75:pre_number = M_3; // 中音mi
    32'D76:pre_number = M_2; // 中音re
    32'D77:pre_number = M_2; // 重复中音re
    32'D78:pre_number = M_1; // 中音do
    32'D79:pre_number = M_1; // 重复中音do
    32'D80:pre_number = M_1; // 中音do
    32'D81:pre_number = M_1; // 重复中音do
    32'D82:pre_number = L_5; // 中音so
    32'D83:pre_number = L_5; // 中音so
    32'D84:pre_number = M_1; // 中音do
    32'D85:pre_number = M_1; // 中音do
    32'D86:pre_number = M_2; // 中音re
    32'D87:pre_number = M_2; // 重复中音re
    32'D88:pre_number = M_3; // 中音mi
    32'D89:pre_number = M_3; // 重复中音mi
    32'D90:pre_number = M_4; // 中音fa
    32'D91:pre_number = M_4; // 重复中音fa
    32'D92:pre_number = M_3; // 中音mi
    32'D93:pre_number = M_3; // 重复中音mi
    32'D94:pre_number = M_2; // 中音re
    32'D95:pre_number = M_2; // 重复中音re
    32'D96:pre_number = L_1; // 低音do
    32'D97:pre_number = M_2; // 重复中音re
    32'D98:pre_number = M_3; // 中音mi
    32'D99:pre_number = 0; // 停顿
    32'D100:pre_number = M_3; // 重复中音mi
    32'D101:pre_number = 0; // 停顿
    32'D102:pre_number = M_3; // 重复中音mi
    32'D103:pre_number = 0; // 停顿
    32'D104:pre_number = M_3; // 重复中音mi
    32'D105:pre_number = M_3; // 重复中音mi
    32'D106:pre_number = M_2; // 中音re
    32'D107:pre_number = M_3; // 中音mi
    32'D108:pre_number = M_2; // 中音re
    32'D109:pre_number = M_2; // 重复中音re
    32'D110:pre_number = M_1; // 中音do
    32'D111:pre_number = M_1; // 重复中音do
    32'D112:pre_number = M_1; // 中音do
    32'D113:pre_number = M_1; // 重复中音do
    default: pre_number = 32'h0;
   endcase
  end
end
```
- 这个部分用于控制乐谱的播放。它通过状态机 `state` 来选择不同的音符，并通过计数器 `beat_time` 来控制每个音符的持续时长。当 `beat_time` 达到预设的时长 `TIME` 时，状态机 `state` 自动切换到下一个音符，并重置 `beat_time`。

这个模块通过时钟信号 `clk` 控制蜂鸣器的频率和乐谱的播放。当蜂鸣器频率改变时，它会发出不同的音调；当乐谱状态机切换到下一个音符时，它会播放不同的音阶。

#### 管脚分配

本组直接通过编写 `snake.xdc` 约束文件来完成引脚分配。

以下是 `snake.xdc` 的引脚和信号分配的表格：

| 信号            | 引脚 | IOSTANDARD  |
|-----------------|-------|-------------|
| clk             | P17   | LVCMOS33    |
| reset           | P15   | LVCMOS33    |
| down            | R17   | LVCMOS33    |
| left            | V1    | LVCMOS33    |
| right           | R11   | LVCMOS33    |
| up              | U4    | LVCMOS33    |
| left_duan[0]    | B4    | LVCMOS33    |
| left_duan[1]    | A4    | LVCMOS33    |
| left_duan[2]    | A3    | LVCMOS33    |
| left_duan[3]    | B1    | LVCMOS33    |
| left_duan[4]    | A1    | LVCMOS33    |
| left_duan[5]    | B3    | LVCMOS33    |
| left_duan[6]    | B2    | LVCMOS33    |
| left_duan[7]    | D5    | LVCMOS33    |
| right_duan[0]   | D4    | LVCMOS33    |
| right_duan[1]   | E3    | LVCMOS33    |
| right_duan[2]   | D3    | LVCMOS33    |
| right_duan[3]   | F4    | LVCMOS33    |
| right_duan[4]   | F3    | LVCMOS33    |
| right_duan[5]   | E2    | LVCMOS33    |
| right_duan[6]   | D2    | LVCMOS33    |
| right_duan[7]   | H2    | LVCMOS33    |
| left_wei[0]     | G2    | LVCMOS33    |
| left_wei[1]     | C2    | LVCMOS33    |
| left_wei[2]     | C1    | LVCMOS33    |
| left_wei[3]     | H1    | LVCMOS33    |
| right_wei[0]    | G1    | LVCMOS33    |
| right_wei[1]    | F1    | LVCMOS33    |
| right_wei[2]    | E1    | LVCMOS33    |
| right_wei[3]    | G6    | LVCMOS33    |
| red[0]          | F5    | LVCMOS33    |
| red[1]          | C6    | LVCMOS33    |
| red[2]          | C5    | LVCMOS33    |
| red[3]          | B7    | LVCMOS33    |
| green[0]        | B6    | LVCMOS33    |
| green[1]        | A6    | LVCMOS33    |
| green[2]        | A5    | LVCMOS33    |
| green[3]        | D8    | LVCMOS33    |
| blue[0]         | C7    | LVCMOS33    |
| blue[1]         | E6    | LVCMOS33    |
| blue[2]         | E5    | LVCMOS33    |
| blue[3]         | E7    | LVCMOS33    |
| hsync           | D7    | LVCMOS33    |
| vsync           | C4    | LVCMOS33    |
| ps2_clk         | K5    | LVCMOS33    |
| ps2_data        | L4    | LVCMOS33    |

- `ps2_clk` 的`CLOCK_DEDICATED_ROUTE` 属性被设置为 `FALSE`。

### 调试过程中的问题及讨论

- 资源占用过多
  - 问题描述：资源超限。
  - 问题分析：代码所占资源太多。
  - 解决方案：优化代码，降低资源使用。

- 随机数超出范围
  - 问题描述：随机数超出范围。
  - 问题分析：随机数生成器可能存在问题。
  - 解决方案：检查随机数生成器，增加二次检测。

- 蛇身过长易头尾分离
  - 问题描述：蛇头和蛇尾分离。
  - 问题分析：贪吃蛇的逻辑主体有误。
  - 解决方案：修改为更好的代码逻辑。

### 设计调试小结

- 本设计分了多个模块，每个模块都进行了详细的分析和设计。
- 每个模块都使用了不同的设计方法和技巧，以提高代码的可读性和可维护性。
- 每个模块都经过了测试和验证，以确保其正确性和可靠性。
- 每个模块都进行了资源占用优化，以减少代码的资源消耗。

# 附件1：各成员心得总结

### 蔡逸文

#### 模块 `smg_ip_model`、`timer_show`、`tablet_show`、`score_show`、`tabletFillingMachine`

- **心得体会**：
  - **模块化设计的重要性**：在负责多个模块的开发过程中，我深刻体会到模块化设计带来的便利性。每个模块有明确的功能定义和接口，便于分工合作和后期维护。
  - **调试技巧**：通过调试 `timer_show` 和 `tabletFillingMachine` 等模块，我学会了如何定位和解决复杂的逻辑问题，尤其是在面对资源限制和性能优化时。
  - **团队协作**：多模块的开发需要与其他团队成员密切配合，尤其是接口的定义和调用。通过有效的沟通和协作，我们能够快速解决问题，提高开发效率。

### 宋健

#### 模块 `fibonacci_lfsr`、`snake_model`、`vga`、`snake`

- **心得体会**：
  - **算法优化**：在开发 `fibonacci_lfsr` 和 `snake_model` 模块时，我学会了如何通过优化算法来提高系统性能，确保系统在处理复杂任务时仍能保持高效。
  - **图形处理**：负责 `vga` 和 `snake` 模块让我对图形处理有了更深入的了解，尤其是在有限资源下如何实现流畅的图形显示和互动。
  - **解决问题**：面对贪吃蛇逻辑中的头尾分离问题，通过深入分析和重新设计逻辑，我学会了从不同角度看待和解决问题的重要性。

### 李宇星

#### 模块 `timer_setting`、`counter`、`Ktime`

- **心得体会**：
  - **时间管理**：在开发 `timer_setting` 和 `Ktime` 模块时，我深刻认识到时间管理在系统中的关键作用。通过精确的时间同步和管理，系统能够更稳定地运行。
  - **细节关注**：负责 `counter` 模块让我认识到细节决定成败。在实现计数功能时，任何微小的逻辑错误都会导致系统异常，因此必须严格检查每一行代码。
  - **学习成长**：通过解决实际问题，我不仅提高了编程能力，还学会了如何在团队中有效沟通，分享和接受不同的观点和建议。

### 范兼玮

#### 模块 `audio_player`、`clock`、`debounce`

- **心得体会**：
  - **音频处理**：在开发 `audio_player` 模块时，我深入学习了音频信号的处理方法，通过添加乐谱状态机等方式，提升了音频效果和系统性能。
  - **时间显示和管理**：负责 `clock` 模块让我对时间显示和管理有了更全面的认识，学会了如何在硬件资源受限的情况下实现精确的时间显示。
  - **抗干扰处理**：通过 `debounce` 模块的开发，我了解了如何通过软件手段解决硬件带来的问题，如按键抖动等。这使我对硬件和软件结合的开发有了更深的理解。
  - **团队合作**：在多个模块的开发过程中，我深刻体会到团队合作的重要性。通过与团队成员的沟通和协作，我们能够快速解决问题，实现系统功能的优化和提升。

通过这次项目的合作开发，我们每个成员都在各自的模块中积累了丰富的经验和技能，同时也深刻体会到团队合作和沟通的重要性。希望在未来的项目中，我们能够继续发扬这种合作精神，共同实现更多的创新和突破。

# 附件2：工作日志

- 因为本课程设计是因为拓展B的软件出现问题而进行的临时更换硬件与软件。

- 采用了最新的 `EGo1` 版来进行探索性的设计。

- 因为临时更换，我们仅使用了两周的时间来完成全部工作。

- 小组成员分工明确，各司其职，顺利完成各项工作。

## A. 电子钟设计

### 完成代码编写

- **于2024年5月1日完成**

### 代码编写完成后的调试任务

**（于2024年5月22日完成）**

1. 调试时间显示功能
2. 修复时间设置功能
3. 优化音频功能
4. 解决按键抖动问题

### 调试过程及问题记录

#### 1. 时间显示功能

- **问题描述**：在实现时间显示时，发现时间无法正常显示。
- **问题分析**：初步怀疑是时间显示模块 (`timer_show`) 逻辑存在错误。
- **解决方案**：仔细检查 `timer_show` 模块的逻辑，发现由于一个变量未正确更新，导致时间显示错误。修复该逻辑后，时间显示恢复正常。

#### 2. 时间设置功能

- **问题描述**：在实现时间设置功能时，发现时间设置功能无法正常工作。
- **问题分析**：经过检查，发现时间设置功能与系统时钟不同步，导致时间无法正确设置。
- **解决方案**：修改代码，添加时间同步机制，使系统时间和设置时间保持一致，问题得到解决。

#### 3. 音频功能优化

- **问题描述**：在实现音频功能时，发现音频工作效果不佳，音质较差且过于单一。
- **问题分析**：可能是音频模块设计不够复杂，未能很好地处理音频信号。
- **解决方案**：添加了乐谱状态机，以丰富音频效果，并对音频模块的处理逻辑进行优化，音质得到显著改善。

#### 4. 按键抖动问题

- **问题描述**：在按键按下时，有时会出现按键抖动的情况，影响用户体验。
- **问题分析**：按键抖动是由于机械开关接触不良等原因产生的短暂信号跳变。
- **解决方案**：在按键处理逻辑中，添加了去抖动模块 `debounce`，通过软件手段消除抖动信号，按键响应变得更加稳定。

### 设计调试小结

- **设计小结**：我们的设计采用分模块方式，每个模块负责特定功能，通过模块之间的协同工作，实现整个系统的功能。这种设计方式分工明确，有助于精准定位和解决问题。
  
- **遇到的问题及解决**：
  - 时间无法正常显示：通过检查 `timer_show` 模块逻辑并修复变量更新问题解决。
  - 时间设置功能失效：通过添加时间同步机制解决。
  - 音频效果不佳：通过引入乐谱状态机和优化音频处理逻辑解决。
  - 按键抖动：通过添加 `debounce` 模块解决。

- **调试过程中的优化建议**：
  - 添加更多注释以解释代码逻辑，增强代码可读性和维护性。
  - 分模块设计的方式使得调试过程更加高效，今后可以继续采用这种方式进行开发。

## B. 药片装瓶系统设计

### 完成代码编写

- **于2024年5月5日完成**

### 代码编写完成后的调试任务

**（于2024年5月24日完成）**

1. 调试按键抖动问题
2. 修复药片增量不正确的问题

### 调试过程及问题记录

#### 1. 按键抖动问题

- **问题描述**：在按键按下时，有时会出现按键抖动的情况。
- **问题分析**：按键抖动是由于机械开关接触不良等原因产生的短暂信号跳变。
- **解决方案**：在按键处理逻辑中，添加了去抖动模块 `debounce`，通过软件手段消除抖动信号，按键响应变得更加稳定。

#### 2. 药片增量不正确

- **问题描述**：药片增量不正确，导致药片填充数量不准确。
- **问题分析**：可能是 `TabletFillingMachine` 模块的 `CAPACITY` 出现了问题，导致药片计数逻辑错误。
- **解决方案**：检查 `TabletFillingMachine` 模块，发现第80行代码存在逻辑错误。将第80行代码修改为 `tablet_cnt == CAPACITY-1` 后，药片增量恢复正常。

### 设计调试小结

- **设计小结**：我们的设计采用分模块方式，每个模块实现特定功能，通过顶层模块将这些功能组合起来，实现了完整的药片填充系统。这种设计方式有助于分工明确和问题定位。

- **遇到的问题及解决**：
  - 按键抖动：通过添加去抖动模块 `debounce` 解决。
  - 药片增量不正确：通过修改 `TabletFillingMachine` 模块的第80行代码解决。

- **调试过程中学到的经验**：
  - 分模块设计不仅有助于调试和维护，还能提高代码的可读性和可扩展性。
  - 在解决具体问题时，要深入分析问题根源，确保彻底解决问题而不是仅仅处理表面症状。
  - 通过调试和问题解决，我们不仅解决了当前的问题，也为未来项目积累了宝贵的经验。

## 自主拓展：贪吃蛇

### 完成代码编写

- **于2024年6月1日完成**

### 代码编写完成后的调试任务

**（于2024年6月3日完成）**

1. 优化代码以减少资源占用
2. 修复随机数超出范围的问题
3. 调整贪吃蛇逻辑，解决蛇头和蛇尾分离问题

### 调试过程及问题记录

#### 1. 资源占用过多

- **问题描述**：代码运行时资源超限，导致系统性能下降。
- **问题分析**：初步检查发现代码中存在大量冗余和低效的处理逻辑，导致资源占用过多。
- **解决方案**：通过重构代码，优化算法，减少不必要的计算和内存占用。重点优化了循环和递归调用，压缩了数据结构，使资源使用大幅降低。

#### 2. 随机数超出范围

- **问题描述**：在生成随机数时，发现部分随机数超出预期范围。
- **问题分析**：随机数生成器的逻辑存在缺陷，未能正确限制生成的范围。
- **解决方案**：检查并修正随机数生成器的实现，添加二次检测机制，确保生成的随机数在预期范围内。

#### 3. 蛇身过长易头尾分离

- **问题描述**：在贪吃蛇游戏中，当蛇身过长时，蛇头和蛇尾容易分离，导致游戏逻辑异常。
- **问题分析**：贪吃蛇的逻辑实现中，未能正确处理蛇身的连接关系，特别是在蛇身较长的情况下。
- **解决方案**：重新设计和实现贪吃蛇的逻辑，确保蛇头和蛇尾始终保持正确的连接关系。优化了蛇身更新的算法，确保在任何情况下蛇头和蛇尾都不会分离。


### 设计调试小结

- **设计小结**：我们的设计分为多个模块，每个模块都进行了详细的分析和设计。通过优化和调整，使得系统在功能和性能上都有了显著提升。

- **遇到的问题及解决**：
  - 资源占用过多：通过代码优化和算法改进，显著降低了资源使用。
  - 随机数超出范围：通过修正随机数生成器和增加检测机制，解决了范围超出问题。
  - 蛇头和蛇尾分离：通过重构贪吃蛇逻辑，确保蛇身在任何情况下都能正确连接。

- **调试过程中的优化建议**：
  - 采用更高效的数据结构和算法，提高代码执行效率。
  - 在实现功能时，注重代码的可读性和可维护性，减少资源消耗。
  - 通过模块化设计，提高代码的可扩展性和可测试性。
